# Auto-generated by Brainsmith Hardware Kernel Generator
# Generated from: brainsmith/kernels/thresholding/thresholding_axi_bw.sv
# Date: 2025-07-07T16:13:11.752850

from brainsmith.core.finn.auto_rtl_backend import AutoRTLBackend
from thresholding_axi_hw_custom_op import ThresholdingAxi
from qonnx.core.datatype import DataType


class thresholding_axi_rtl(ThresholdingAxi, AutoRTLBackend):
    """RTL backend for thresholding_axi operation.
    
    Auto-generated from SystemVerilog RTL analysis.
    Uses explicit parameter resolution generated at compile-time.
    """
    
    def __init__(self, onnx_node, **kwargs):
        super().__init__(onnx_node, **kwargs)
    
    @property
    def finn_rtllib_module(self) -> str:
        """Return finn-rtllib module name for this operation."""
        return ""
    
    def get_nodeattr_types(self):
        """Define all node attributes including RTL-specific parameters."""
        # Get interface datatype attributes from HWCustomOp parent
        my_attrs = super().get_nodeattr_types()
        
        # Add RTL-specific algorithm parameters
        rtl_attrs = {
            "input_FPARG": ('i', True, None),
            "BIAS": ('i', True, None),
            "THRESHOLDS_PATH": ('s', False, ''),
            "USE_AXILITE": ('i', True, None),
            "DEPTH_TRIGGER_URAM": ('i', True, None),
            "DEPTH_TRIGGER_BRAM": ('i', True, None),
            "DEEP_PIPELINE": ('i', True, None),
            "thresholdDataType": ('s', False, 'INT8'),
        }
        my_attrs.update(rtl_attrs)
        
        # Add HDL generation attributes
        my_attrs.update({
            "gen_top_module": ("s", False, ""),
            "ipgen_path": ("s", False, ""),
            "ip_path": ("s", False, ""),
        })
        
        return my_attrs
    
    def prepare_codegen_rtl_values(self, model):
        """Explicit parameter resolution for RTL template generation."""
        code_gen_dict = {}
        
        # Basic module information
        code_gen_dict["$MODULE_NAME_AXI_WRAPPER$"] = [self.get_verilog_top_module_name()]
        code_gen_dict["$TOP_MODULE$"] = code_gen_dict["$MODULE_NAME_AXI_WRAPPER$"]
        
        # Standard stream width variables
        code_gen_dict["$IBITS$"] = [str(self.get_instream_width())]
        code_gen_dict["$OBITS$"] = [str(self.get_outstream_width())]
        
        # Explicit parameter assignments (generated from CodegenBinding at compile-time)
        code_gen_dict["$INPUT_BDIM$"] = [str(self._get_interface_bdim("input", 0))]  # Block dimension from KernelModel for input
        code_gen_dict["$INPUT_SDIM$"] = [str(self._get_interface_sdim("input", 0))]  # Stream dimension from KernelModel for input
        code_gen_dict["$INPUT_FPARG$"] = [str(self.get_nodeattr("input_FPARG"))]  # Algorithm parameter input_FPARG
        code_gen_dict["$BIAS$"] = [str(self.get_nodeattr("BIAS"))]  # Algorithm parameter BIAS
        code_gen_dict["$THRESHOLDS_PATH$"] = [str(self.get_nodeattr("THRESHOLDS_PATH"))]  # Algorithm parameter THRESHOLDS_PATH
        code_gen_dict["$DEPTH_TRIGGER_URAM$"] = [str(self.get_nodeattr("DEPTH_TRIGGER_URAM"))]  # Algorithm parameter DEPTH_TRIGGER_URAM
        code_gen_dict["$DEPTH_TRIGGER_BRAM$"] = [str(self.get_nodeattr("DEPTH_TRIGGER_BRAM"))]  # Algorithm parameter DEPTH_TRIGGER_BRAM
        code_gen_dict["$DEEP_PIPELINE$"] = [str(self.get_nodeattr("DEEP_PIPELINE"))]  # Algorithm parameter DEEP_PIPELINE
        code_gen_dict["$INPUT_WIDTH$"] = [str(self._get_interface_width("input"))]  # Interface input width from KernelModel
        code_gen_dict["$INPUT_SIGNED$"] = [str(1 if self._get_interface_signed("input") else 0)]  # Interface input signed from KernelModel
        code_gen_dict["$OUTPUT_WIDTH$"] = [str(self._get_interface_width("output"))]  # Interface output width from KernelModel
        code_gen_dict["$T_WIDTH$"] = [str(DataType[self.get_nodeattr("thresholdDataType")].bitwidth())]  # Internal threshold width parameter
        
        return code_gen_dict
    
    def get_supporting_rtl_files(self) -> list:
        """Get list of supporting RTL files to include."""
        return [
        ]
    
    def generate_hdl(self, model, fpgapart, clk):
        """Generate HDL from pre-generated wrapper template."""
        import os
        import shutil
        
        # Get code generation directory
        code_gen_dir = self.get_nodeattr("code_gen_dir_ipgen")
        os.makedirs(code_gen_dir, exist_ok=True)
        
        # Save top module name
        topname = self.get_verilog_top_module_name()
        self.set_nodeattr("gen_top_module", topname)
        
        # Get template variables
        code_gen_dict = self.prepare_codegen_rtl_values(model)
        
        # Add missing stream width variables
        code_gen_dict["$INPUT_STREAM_WIDTH$"] = [str(self.get_instream_width())]
        code_gen_dict["$OUTPUT_STREAM_WIDTH$"] = [str(self.get_outstream_width())]
        
        # Find the pre-generated wrapper template
        module_dir = os.path.dirname(os.path.abspath(__file__))
        wrapper_name = "thresholding_axi_wrapper.v"
        wrapper_path = os.path.join(module_dir, wrapper_name)
        
        if os.path.exists(wrapper_path):
            # Read wrapper template
            with open(wrapper_path, "r") as f:
                template_content = f.read()
            
            # Apply template substitution
            for placeholder, values in code_gen_dict.items():
                value = values[0] if isinstance(values, list) and values else str(values)
                template_content = template_content.replace(placeholder, value)
            
            # Write processed wrapper
            output_path = os.path.join(code_gen_dir, f"{topname}.v")
            with open(output_path, "w") as f:
                f.write(template_content)
        else:
            raise FileNotFoundError(
                f"Wrapper template not found at {wrapper_path}. "
                "Ensure the wrapper file is in the same directory as this RTL backend."
            )
        
        # Copy supporting RTL files if specified
        for rtl_file in self.get_supporting_rtl_files():
            if os.path.exists(rtl_file):
                shutil.copy(rtl_file, code_gen_dir)
            else:
                print(f"Warning: Supporting RTL file not found: {rtl_file}")
        
        # Set paths for downstream tools
        self.set_nodeattr("ipgen_path", code_gen_dir)
        self.set_nodeattr("ip_path", code_gen_dir)
    
