version: "3.0"
name: "Semantic Types Example"
description: "Blueprint demonstrating semantic input/output type shortcuts"

hw_compiler:
  kernels:
    - "MatMul"
    - "LayerNorm"
  
  transforms:
    pre_quantization: ["streamline"]
    quantization: ["quantize"]
    post_quantization: ["convert_to_hw"]
  
  config_flags:
    target_device: "xczu7ev"

processing:
  preprocessing:
    - name: "normalization"
      options:
        - enabled: true

search:
  strategy: "exhaustive"

global:
  output_stage: "rtl"
  working_directory: "./semantic_builds"
  
  # Semantic type configuration examples:
  
  # Build only the hardware inference portion
  input_type: "hwgraph"    # Start from: step_create_dataflow_partition
  output_type: "hwgraph"   # Stop at: custom_step_infer_hardware
  
  # Available input types:
  # - "onnx": Start from raw ONNX model (custom_step_cleanup)
  # - "qonnx": Start from QONNX model (custom_step_qonnx2finn)
  # - "finn": Start from FINN dataflow graph (custom_streamlining_step)
  # - "hwgraph": Start from hardware dataflow graph (step_create_dataflow_partition)
  
  # Available output types:
  # - "qonnx": Stop at QONNX conversion (custom_step_qonnx2finn)
  # - "finn": Stop at FINN dataflow graph (custom_streamlining_step)
  # - "hwgraph": Stop at hardware inference (custom_step_infer_hardware)
  # - "rtl": Stop at RTL generation (step_hw_codegen)
  # - "ip": Stop at IP generation (step_hw_ipgen)
  # - "bitstream": Stop at bitstream generation (step_create_stitched_ip)