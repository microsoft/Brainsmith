{#-
AutoHWCustomOp Subclass Template V2 - Direct KernelMetadata Access

This template generates AutoHWCustomOp subclasses using direct metadata access.
Key changes from V1:
- Direct access to metadata properties
- No TemplateContext dependency
- Cleaner variable references
-#}
############################################################################
# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.
#
# Auto-generated HWCustomOp for {{ kernel_metadata.name }}
# Generated from: {{ kernel_metadata.source_file }}
# Generation timestamp: {{ generation_timestamp }}
#
# This HWCustomOp uses the modern AutoHWCustomOp base class with explicit
# parameter definitions and no runtime binding dependencies.
############################################################################

from typing import List, Dict, Tuple, Any
import numpy as np
from qonnx.core.datatype import DataType

from brainsmith.core.finn.auto_hw_custom_op import AutoHWCustomOp
from brainsmith.core.dataflow import (
    KernelDefinition,
    InputDefinition,
    OutputDefinition,
    RelationType
)
from brainsmith.core.dataflow.qonnx_types import DatatypeConstraintGroup


class {{ kernel_metadata.class_name }}(AutoHWCustomOp):
    """
    Auto-generated HWCustomOp for {{ kernel_metadata.name }} kernel.
    
    Generated from RTL: {{ kernel_metadata.source_file }}
    Uses AutoHWCustomOp for automatic FINN method implementation.
    """
    
    def __init__(self, onnx_node, **kwargs):
        super().__init__(onnx_node, **kwargs)
    
    @property
    def kernel_name(self) -> str:
        """Return kernel name for this operation."""
        return "{{ kernel_metadata.name }}"
    
    def get_nodeattr_types(self):
        """
        Define all node attributes for {{ kernel_metadata.name }}.
        
        Generated from RTL analysis of interfaces and parameters.
        Returns comprehensive attribute definitions for FINN integration.
        """
        # Start with base AutoHWCustomOp attributes
        attrs = super().get_nodeattr_types()
        
        # Update with kernel-specific attributes
        attrs.update({
            # Interface datatype attributes (required by FINN)
            {% for interface in kernel_metadata.input_interfaces + kernel_metadata.output_interfaces %}
            "{{ interface.name }}DataType": ('s', True, ""),
            {% endfor %}
            
            # SHAPE parameters from interfaces
            {% for param in kernel_metadata.parameters %}
            {% if param.category.value == 'shape' and param.is_exposed %}
            "{{ param.name }}": ('i', True, {{ param.default_value or 0 }}),
            {% endif %}
            {% endfor %}
            
            {% if kernel_metadata.weight_interfaces %}
            "ram_style": ('s', False, 'auto', {'auto', 'block', 'distributed', 'ultra'}),
            {% endif %}
        })
        
        return attrs
    
    def define_kernel(self, dt_dict: Dict[str, Any]) -> KernelDefinition:
        """
        Define kernel for {{ kernel_metadata.name }}.
        
        Creates explicit KernelDefinition with:
        - Interface specifications with datatype constraints
        - Dimensional relationships between interfaces
        - No runtime parameter extraction needed
        """
        kernel_def = KernelDefinition("{{ kernel_metadata.name }}")
        
        # Add input definitions
        {% for interface in kernel_metadata.input_interfaces %}
        input_def = InputDefinition(
            name="{{ interface.name }}",
            datatype_constraints=[
                {% for constraint in interface.datatype_constraints %}
                DatatypeConstraintGroup(
                    base_type="{{ constraint.base_type }}",
                    min_width={{ constraint.min_width }},
                    max_width={{ constraint.max_width }}
                ),
                {% endfor %}
            ],
            {% if interface.bdim_shape %}
            block_tiling={{ interface.bdim_shape | tojson }}
            {% endif %}
        )
        kernel_def.add_input(input_def)
        {% endfor %}
        
        # Add weight definitions
        {% for interface in kernel_metadata.weight_interfaces %}
        weight_def = InputDefinition(
            name="{{ interface.name }}",
            datatype_constraints=[
                {% for constraint in interface.datatype_constraints %}
                DatatypeConstraintGroup(
                    base_type="{{ constraint.base_type }}",
                    min_width={{ constraint.min_width }},
                    max_width={{ constraint.max_width }}
                ),
                {% endfor %}
            ],
            {% if interface.bdim_shape %}
            block_tiling={{ interface.bdim_shape | tojson }},
            {% endif %}
            is_weight=True
        )
        kernel_def.add_input(weight_def)
        {% endfor %}
        
        # Add output definitions
        {% for interface in kernel_metadata.output_interfaces %}
        output_def = OutputDefinition(
            name="{{ interface.name }}",
            datatype_constraints=[
                {% for constraint in interface.datatype_constraints %}
                DatatypeConstraintGroup(
                    base_type="{{ constraint.base_type }}",
                    min_width={{ constraint.min_width }},
                    max_width={{ constraint.max_width }}
                ),
                {% endfor %}
            ],
            {% if interface.bdim_shape %}
            block_tiling={{ interface.bdim_shape | tojson }}
            {% endif %}
        )
        kernel_def.add_output(output_def)
        {% endfor %}
        
        # Add relationships
        {% for rel in kernel_metadata.relationships %}
        kernel_def.add_relationship(
            source_name="{{ rel.source_interface }}",
            target_name="{{ rel.target_interface }}",
            relationship_type=RelationType.{{ rel.relation.name }},
            {% if rel.source_dim is not none %}source_dim={{ rel.source_dim }},{% endif %}
            {% if rel.target_dim is not none %}target_dim={{ rel.target_dim }},{% endif %}
            {% if rel.factor is not none %}factor={{ rel.factor }},{% endif %}
            {% if rel.dependency_type %}dependency_type="{{ rel.dependency_type }}"{% endif %}
        )
        {% endfor %}
        return kernel_def
    
    {% if kernel_metadata.exposed_parameters %}
    def verify_node(self) -> List[str]:
        """Verify kernel-specific constraints."""
        messages = super().verify_node()
        
        # Verify all required parameters are present
        {% for param in kernel_metadata.exposed_parameters %}
        if self.get_nodeattr("{{ param }}") is None:
            messages.append(f"✗ Required parameter '{{ param }}' not specified")
        {% endfor %}
        
        # Additional {{ kernel_metadata.name }}-specific verification
        {% if kernel_metadata.has_datatype_parameters %}
        # Verify datatype consistency
        if not self._verify_datatype_consistency():
            messages.append(f"✗ Datatype parameters do not match interface constraints")
        {% endif %}
        
        return messages
    {% endif %}
    
    def get_exp_cycles(self):
        """Calculate expected cycles for {{ kernel_metadata.name }}."""
        # Default cycle calculation - override in specialized implementations
        return 1
    
    def get_folded_input_shape(self, ind=0):
        """Get folded input shape (with SIMD/PE folding applied)."""
        # Implementation provided by AutoHWCustomOp
        return super().get_folded_input_shape(ind)
    
    def get_folded_output_shape(self, ind=0):
        """Get folded output shape (with SIMD/PE folding applied)."""
        # Implementation provided by AutoHWCustomOp
        return super().get_folded_output_shape(ind)


# Kernel metadata for reference
"""
{{ kernel_metadata.name }} Kernel Specification:

Core Functionality:
- Module: {{ kernel_metadata.module_name }}
- Top Function: {{ kernel_metadata.module_name }}

Interfaces:
{% for interface in kernel_metadata.input_interfaces %}
- Input: {{ interface.name }}
{% endfor %}
{% for interface in kernel_metadata.output_interfaces %}
- Output: {{ interface.name }}
{% endfor %}
{% for interface in kernel_metadata.weight_interfaces %}
- Weight: {{ interface.name }}
{% endfor %}

Parameterization:
{% for interface in kernel_metadata.input_interfaces + kernel_metadata.output_interfaces %}
- {{ interface.name }}DataType: Interface datatype selection
{% endfor %}

{% for param in kernel_metadata.parameters %}
{% if param.category.value == 'shape' and param.is_exposed %}
- {{ param.name }}: int (required)
{% endif %}
{% endfor %}

{% if kernel_metadata.weight_interfaces %}
Hardware optimization hints:
- ram_style: str = 'auto'
{% endif %}
"""