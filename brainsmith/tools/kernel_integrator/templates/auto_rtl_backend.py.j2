# Auto-generated by Brainsmith Kernel Integrator for {{ kernel_metadata.name }}
# Generated from: {{ kernel_metadata.source_file }}

from typing import List, Dict, Tuple, Any
import os
import shutil
from pathlib import Path

from brainsmith._internal.finn.auto_rtl_backend import AutoRTLBackend
from .{{ kernel_metadata.name }} import {{ kernel_metadata.class_name }}
from qonnx.core.datatype import DataType


class {{ kernel_metadata.class_name }}_rtl({{ kernel_metadata.class_name }}, AutoRTLBackend):
    """
    RTL backend for {{ kernel_metadata.name }} operation.
    
    Auto-generated from SystemVerilog RTL: {{ kernel_metadata.source_file }}
    Uses direct parameter resolution from KernelMetadata structure.
    """
    
    def __init__(self, onnx_node, **kwargs):
        """Initialize {{ kernel_metadata.name }}_rtl backend."""
        super().__init__(onnx_node, **kwargs)
    
    def get_nodeattr_types(self):
        """
        Define all node attributes including RTL-specific parameters.
        
        Inherits interface attributes from HWCustomOp parent and adds
        RTL-specific algorithm parameters.
        """
        # Get interface datatype attributes from HWCustomOp parent
        my_attrs = super().get_nodeattr_types()
        
        # Add RTL-specific algorithm parameters
        rtl_attrs = {
            {% for param in kernel_metadata.parameters %}
            "{{ param.nodeattr_name }}": ('{{ 's' if param.is_string_type() else 'i' }}', True, {{ param.resolved_default or 'None' }}),
            {% endfor %}
            {% if kernel_metadata.config %}
            # Configuration interface parameters
            {% for interface in kernel_metadata.config %}
            {% if interface.dtype_params and interface.dtype_params.width %}
            "{{ interface.dtype_params.width.nodeattr_name }}": ('i', True, {{ interface.dtype_params.width.resolved_default or 'None' }}),
            {% endif %}
            {% endfor %}
            # AXI-Lite enable parameter
            "USE_AXILITE": ('i', True, 1),  # Has AXI-Lite config interface
            {% else %}
            # AXI-Lite enable parameter
            "USE_AXILITE": ('i', True, 0),  # No AXI-Lite interface
            {% endif %}
            {% for interface in kernel_metadata.config %}
            {% if interface.name.lower() == "threshold" %}
            # Threshold datatype parameter
            "thresholdDataType": ('s', True, 'INT8'),  # Default threshold datatype
            {% endif %}
            {% endfor %}
        }
        my_attrs.update(rtl_attrs)
        
        # Add HDL generation attributes
        my_attrs.update({
            "gen_top_module": ("s", False, ""),
            "ipgen_path": ("s", False, ""),
            "ip_path": ("s", False, ""),
        })
        
        return my_attrs
    
    def prepare_codegen_rtl_values(self, model):
        """
        Prepare parameter values for RTL code generation.
        
        Maps node attributes and interface properties to RTL template variables.
        Uses direct access to generate clear, traceable mappings.
        """
        code_gen_dict = {}
        
        # Basic module information
        code_gen_dict["$MODULE_NAME_AXI_WRAPPER$"] = [self.get_verilog_top_module_name()]
        code_gen_dict["$TOP_MODULE$"] = code_gen_dict["$MODULE_NAME_AXI_WRAPPER$"]
        
        # Standard stream width variables
        code_gen_dict["$IBITS$"] = [str(self.get_instream_width())]
        code_gen_dict["$OBITS$"] = [str(self.get_outstream_width())]
        
        # Direct parameter assignments from KernelMetadata
        {% for param in kernel_metadata.parameters %}
        code_gen_dict["${{ param.name.upper() }}$"] = [str(self.get_nodeattr("{{ param.nodeattr_name }}"))]
        {% endfor %}
        
        # Interface-specific parameters
        {% for interface in kernel_metadata.stream_interfaces %}
        {% if interface.bdim_params %}
        # {{ interface.name }} BDIM parameters
        {% for param in interface.bdim_params %}
        code_gen_dict["${{ param.name.upper() }}$"] = [str(self._get_interface_bdim("{{ interface.compiler_name }}", {{ loop.index0 }}))]
        {% endfor %}
        {% endif %}
        {% if interface.sdim_params %}
        # {{ interface.name }} SDIM parameters  
        {% for param in interface.sdim_params %}
        code_gen_dict["${{ param.name.upper() }}$"] = [str(self._get_interface_sdim("{{ interface.compiler_name }}", {{ loop.index0 }}))]
        {% endfor %}
        {% endif %}
        {% endfor %}
        
        # Interface datatype widths
        {% for interface in kernel_metadata.stream_interfaces %}
        code_gen_dict["${{ interface.name.upper() }}_WIDTH$"] = [str(self._get_interface_width("{{ interface.compiler_name }}"))]
        {% if interface.dtype_params and interface.dtype_params.signed %}
        code_gen_dict["${{ interface.name.upper() }}_SIGNED$"] = [str(1 if self._get_interface_signed("{{ interface.compiler_name }}") else 0)]
        {% endif %}
        {% endfor %}
        
        # Config interface parameters
        {% for interface in kernel_metadata.config %}
        {% if interface.dtype_params and interface.dtype_params.width %}
        code_gen_dict["${{ interface.dtype_params.width.name.upper() }}$"] = [str(self.get_nodeattr("{{ interface.dtype_params.width.nodeattr_name }}"))]
        {% endif %}
        {% endfor %}
        
        # Standard interface width mappings
        {% for interface in kernel_metadata.inputs %}
        code_gen_dict["${{ interface.name.upper() }}_STREAM_WIDTH$"] = [str(self._get_interface_width("{{ interface.compiler_name }}"))]
        {% endfor %}
        {% for interface in kernel_metadata.outputs %}
        code_gen_dict["${{ interface.name.upper() }}_STREAM_WIDTH$"] = [str(self._get_interface_width("{{ interface.compiler_name }}"))]
        {% endfor %}
        
        # AXI-Lite configuration enable
        {% if kernel_metadata.config %}
        code_gen_dict["$USE_AXILITE$"] = [str(1)]
        {% else %}
        code_gen_dict["$USE_AXILITE$"] = [str(0)]
        {% endif %}
        
        # Extract PE and CHANNELS parameters if they exist
        # These often appear in shape expressions but need to be available as parameters
        if hasattr(self, 'get_nodeattr'):
            try:
                pe_val = self.get_nodeattr("PE")
                code_gen_dict["$PE$"] = [str(pe_val)]
            except Exception:
                pass
            try:
                channels_val = self.get_nodeattr("CHANNELS")
                code_gen_dict["$CHANNELS$"] = [str(channels_val)]
            except Exception:
                pass
        
        return code_gen_dict
    
    def get_included_rtl_filenames(self) -> List[str]:
        """Get list of included RTL file names (basename only)."""
        {% if kernel_metadata.included_rtl_files %}
        return [
            {% for rtl_file in kernel_metadata.included_rtl_files %}
            os.path.basename("{{ rtl_file }}"),
            {% endfor %}
        ]
        {% else %}
        return ["{{ kernel_metadata.name }}.sv"]
        {% endif %}
    
    def generate_hdl(self, model, fpgapart, clk):
        """Generate HDL from pre-generated wrapper template."""
        # Get code generation directory
        code_gen_dir = self.get_nodeattr("code_gen_dir_ipgen")
        os.makedirs(code_gen_dir, exist_ok=True)
        
        # Save top module name
        topname = self.get_verilog_top_module_name()
        self.set_nodeattr("gen_top_module", topname)
        
        {% if kernel_metadata.has_weights %}
        # Generate initialization files if model provided
        if model:
            self.generate_init_files(model, code_gen_dir)
        
        {% endif %}
        # Get template variables
        code_gen_dict = self.prepare_codegen_rtl_values(model)
        
        # Find the pre-generated wrapper template
        module_dir = Path(__file__).parent
        wrapper_name = "{{ kernel_metadata.name }}_wrapper.v"
        wrapper_path = module_dir / wrapper_name
        
        if wrapper_path.exists():
            # Read wrapper template
            with open(wrapper_path, "r") as f:
                template_content = f.read()
            
            # Apply template substitution
            for placeholder, values in code_gen_dict.items():
                value = values[0] if isinstance(values, list) and values else str(values)
                template_content = template_content.replace(placeholder, value)
            
            # Write processed wrapper
            output_path = os.path.join(code_gen_dir, f"{topname}.v")
            with open(output_path, "w") as f:
                f.write(template_content)
        else:
            raise FileNotFoundError(
                f"Wrapper template not found at {wrapper_path}. "
                "Ensure the wrapper file is in the same directory as this RTL backend."
            )
        
        # Copy all included RTL files from kernel metadata
        {% if kernel_metadata.included_rtl_files %}
        included_files = {{ kernel_metadata.included_rtl_files }}
        self.copy_included_rtl_files(included_files, code_gen_dir)
        {% else %}
        # Fallback: copy kernel RTL file if no included files specified
        kernel_rtl_path = module_dir / "{{ kernel_metadata.name }}.sv"
        if kernel_rtl_path.exists():
            shutil.copy(str(kernel_rtl_path), code_gen_dir)
        {% endif %}
        
        # Set paths for downstream tools
        self.set_nodeattr("ipgen_path", code_gen_dir)
        self.set_nodeattr("ip_path", code_gen_dir)
    
    {% if kernel_metadata.has_weights %}
    def generate_init_files(self, model, code_gen_dir):
        """
        Generate initialization files (weights, thresholds, etc.) for the kernel.
        
        This method is called during HDL generation to create memory initialization
        files that your RTL will read during synthesis or runtime.
        
        Args:
            model: ONNX model containing initializers (use model.get_initializer())
            code_gen_dir: Directory where all generated files should be written
        
        Common patterns:
        1. Extract weights: weights = model.get_initializer(self.onnx_node.input[1])
        2. Apply transformations (padding, reordering, type conversion)
        3. Generate file(s) based on your RTL's memory architecture
        4. Set RTL parameters for file paths (in prepare_codegen_rtl_values)
        """
        # Step 1: Extract weight tensor(s) from model
        # weights = model.get_initializer(self.onnx_node.input[1])
        # if weights is None:
        #     return
        
        # Step 2: Get necessary parameters
        # pe = self.get_nodeattr("PE")
        # channels = self.get_nodeattr("NumChannels")
        # wdt = self.get_input_datatype(1)  # Weight datatype
        
        # Step 3: Transform weights if needed
        # - Reshape for your memory layout
        # - Apply quantization adjustments
        # - Handle special cases (single value broadcast, etc.)
        
        # Step 4: Generate file(s) according to your RTL's expectations
        # self.make_weight_file(weights, "decoupled", weight_file_name)
        
        raise NotImplementedError(
            f"generate_init_files() not implemented for {self.__class__.__name__}.\n"
            "See 'Weight File Generation Guide' for implementation instructions."
        )
    
    def make_weight_file(self, weights, weight_file_mode, weight_file_name):
        """
        Generate a single weight initialization file.
        
        This is a utility method called by generate_init_files() to write
        weights in the specific format expected by your RTL.
        
        Args:
            weights: numpy array with weight values (already transformed)
            weight_file_mode: 'decoupled' for synthesis, 'const' for runtime
            weight_file_name: full path where weight file should be written
        
        Common formats:
        - Hex values, one per line: "0xFF" or "FF"
        - Binary values: "10110101"
        - Decimal values: "255"
        - Packed formats: multiple values per line
        """
        # Example hex format implementation:
        # from finn.util.data_packing import pack_innermost_dim_as_hex_string
        # from qonnx.util.basic import roundup_to_integer_multiple
        # 
        # wdt = self.get_input_datatype(1)  # Or get from weights
        # bw_hexdigit = roundup_to_integer_multiple(wdt.bitwidth(), 4)
        # weight_tensor_expanded = np.expand_dims(weights.flatten(), axis=-1)
        # weight_packed = pack_innermost_dim_as_hex_string(
        #     weight_tensor_expanded, wdt, bw_hexdigit, prefix=""
        # )
        # 
        # with open(weight_file_name, "w") as f:
        #     for val in weight_packed.flatten():
        #         f.write(val + "\n")
        
        raise NotImplementedError(
            f"make_weight_file() not implemented for {self.__class__.__name__}.\n"
            "Implement based on your RTL's expected weight file format."
        )
    
    def get_all_meminit_filenames(self, abspath=False):
        """
        Return a list of all memory initializer files generated by this node.
        
        This is used by the build system to track generated files and include
        them in the IP packaging process.
        
        Args:
            abspath: If True, return absolute paths; if False, relative to code_gen_dir
            
        Returns:
            List of file paths for all generated .dat/.mem files
        
        Must match the files actually created by generate_init_files().
        """
        # Build the same list of files that generate_init_files() creates
        # Example for distributed weights:
        # dat_files = []
        # t_path = self.get_nodeattr("code_gen_dir_ipgen") if abspath else "."
        # pe = self.get_nodeattr("PE") 
        # 
        # for pe_idx in range(pe):
        #     weight_file = os.path.join(t_path, f"{self.onnx_node.name}_weights_{pe_idx}.dat")
        #     dat_files.append(weight_file)
        # 
        # return dat_files
        
        raise NotImplementedError(
            f"get_all_meminit_filenames() not implemented for {self.__class__.__name__}.\n"
            "Must return list of all weight files generated by generate_init_files()."
        )
    {% endif %}
    
    def get_verilog_top_module_intf_names(self):
        """Return interface names for Verilog module based on actual RTL signal names."""
        intf_names = {}
        
        # Clock and reset signals from control interface
        intf_names["clk"] = ["{{ kernel_metadata.control.clk.name }}"]
        intf_names["rst"] = ["{{ kernel_metadata.control.rst_n.name }}"]
        
        # Stream interface names based on kernel metadata
        {% set input_idx = namespace(value=0) %}
        {% if kernel_metadata.inputs %}
        # Input stream interfaces (excluding weights)
        intf_names["s_axis"] = [
        {% for interface in kernel_metadata.inputs if not interface.is_weight %}
            ("in{{ input_idx.value }}_V", self.get_instream_width_padded({{ input_idx.value }})),
        {% set input_idx.value = input_idx.value + 1 %}
        {% endfor %}
        ]
        {% endif %}
        
        {% if kernel_metadata.outputs %}
        # Output stream interfaces
        intf_names["m_axis"] = [
        {% for interface in kernel_metadata.outputs %}
            ("out{{ loop.index0 }}_V", self.get_outstream_width_padded({{ loop.index0 }})),
        {% endfor %}
        ]
        {% endif %}
        
        {% if kernel_metadata.config %}
        # AXI-Lite interface for configuration
        if self.get_nodeattr("USE_AXILITE") == 1:
            axilite_interfaces = []
            {% for interface in kernel_metadata.config %}
            axilite_interfaces.append("{{ interface.compiler_name }}")
            {% endfor %}
            intf_names["axilite"] = axilite_interfaces
        {% endif %}
        
        return intf_names
    
    ############################################################################
    # ======================= MANUALLY IMPLEMENT FUNCTIONS BELOW ===============
    # Add any custom methods specific to your RTL backend here
    ############################################################################


# Kernel metadata reference
"""
{{ kernel_metadata.name }} RTL Backend Specification:

Module: {{ kernel_metadata.name }}
Source: {{ kernel_metadata.source_file }}

Parameters:
{% for param in kernel_metadata.parameters %}
- {{ param.name }}: RTL parameter (nodeattr: {{ param.nodeattr_name }})
{% endfor %}

Interfaces:
{% for interface in kernel_metadata.inputs %}
- {{ interface.name }}: INPUT interface{% if interface.is_weight %} (weight){% endif %}
{% endfor %}
{% for interface in kernel_metadata.outputs %}
- {{ interface.name }}: OUTPUT interface
{% endfor %}
{% if kernel_metadata.config %}
{% for interface in kernel_metadata.config %}
- {{ interface.name }}: CONFIG interface (AXI-Lite)
{% endfor %}
{% endif %}

Template Variables Generated:
- Module and stream width variables
{% for param in kernel_metadata.parameters %}
- ${{ param.name.upper() }}$: from nodeattr '{{ param.nodeattr_name }}'
{% endfor %}
{% for interface in kernel_metadata.stream_interfaces %}
- ${{ interface.name.upper() }}_WIDTH$: interface datatype width
{% for param in interface.bdim_params %}
- ${{ param.name.upper() }}$: {{ interface.name }} BDIM parameter
{% endfor %}
{% for param in interface.sdim_params %}
- ${{ param.name.upper() }}$: {{ interface.name }} SDIM parameter
{% endfor %}
{% endfor %}
"""