# Auto-generated by Brainsmith Hardware Kernel Generator
# Generated from: /home/tafk/dev/brainsmith-2/brainsmith/tools/hw_kernel_gen/tests/test_kernel_e2e.sv
# Date: 2025-06-20T06:52:46.954790

from brainsmith.dataflow.core.auto_rtl_backend import AutoRTLBackend
from qonnx.core.datatype import DataType
from brainsmith.dataflow.core.auto_rtl_backend import AdvancedMemoryMixin


class test_kernel_e2e_rtl(AdvancedMemoryMixin, AutoRTLBackend):
    """RTL backend for test_kernel_e2e operation.
    
    Auto-generated from SystemVerilog RTL analysis.
    
    Hardware accelerator operation: test_kernel_e2e
    """
    
    def __init__(self, onnx_node, **kwargs):
        super().__init__(onnx_node, **kwargs)
    
    @property
    def finn_rtllib_module(self) -> str:
        """Return finn-rtllib module name for this operation."""
        return "test_kernel_e2e"
    
    def get_nodeattr_types(self):
        """Get node attribute types for RTLBackend (algorithm parameters only)."""
        my_attrs = {}
        
        # Only expose algorithm parameters (exposed parameters only)
        # Algorithm parameter - optional with default
        my_attrs["INPUT_BDIM"] = ("i", False, 1)
        # Algorithm parameter - optional with default
        my_attrs["INPUT_SDIM"] = ("i", False, 1)
        # Algorithm parameter - optional with default
        my_attrs["WEIGHT_BDIM"] = ("i", False, 1)
        # Algorithm parameter - optional with default
        my_attrs["ACTIVATION_TYPE"] = ("i", False, 1)
        
        # Standardized AXI-Lite configuration support
        my_attrs["axilite_config"] = ("i", False, 1, {0, 1})
        
        # Merge with parent class attributes
        my_attrs.update(AutoRTLBackend.get_nodeattr_types(self))
        
        return my_attrs
    
    def prepare_codegen_rtl_values(self, model):
        """Prepare template variables for RTL code generation.
        
        All dictionary values produced in this function are to replace
        their key value(s) in the RTL template files following FINN's pattern.
        """
        code_gen_dict = {}
        
        # Basic module information
        code_gen_dict["$MODULE_NAME_AXI_WRAPPER$"] = [self.get_verilog_top_module_name()]
        code_gen_dict["$TOP_MODULE$"] = code_gen_dict["$MODULE_NAME_AXI_WRAPPER$"]
        
        # Standard stream width variables
        code_gen_dict["$IBITS$"] = [str(self.get_instream_width())]
        code_gen_dict["$OBITS$"] = [str(self.get_outstream_width())]
        
        # Algorithm parameters from node attributes
        code_gen_dict["$INPUT_BDIM$"] = [str(self.get_nodeattr("INPUT_BDIM"))]
        code_gen_dict["$INPUT_SDIM$"] = [str(self.get_nodeattr("INPUT_SDIM"))]
        code_gen_dict["$WEIGHT_BDIM$"] = [str(self.get_nodeattr("WEIGHT_BDIM"))]
        # Derived parameter - computed from expression
        code_gen_dict["$MEM_DEPTH$"] = [str(self.calc_memory_depth())]

        code_gen_dict["$ACTIVATION_TYPE$"] = [str(self.get_nodeattr("ACTIVATION_TYPE"))]
        
        # BDIM/SDIM parameter linkage (from interface metadata)
        interface_metadata = self.get_interface_metadata()
        for interface in interface_metadata:
            # BDIM parameter linkage
            if hasattr(interface, 'bdim_param') and interface.bdim_param:
                bdim_value = self.get_nodeattr(interface.bdim_param) if interface.bdim_param in ['INPUT_BDIM', 'INPUT_SDIM', 'WEIGHT_BDIM', 'ACTIVATION_TYPE'] else None
                if bdim_value is not None:
                    code_gen_dict[f"${interface.bdim_param.upper()}$"] = [str(bdim_value)]
            
            # SDIM parameter linkage  
            if hasattr(interface, 'sdim_param') and interface.sdim_param:
                sdim_value = self.get_nodeattr(interface.sdim_param) if interface.sdim_param in ['INPUT_BDIM', 'INPUT_SDIM', 'WEIGHT_BDIM', 'ACTIVATION_TYPE'] else None
                if sdim_value is not None:
                    code_gen_dict[f"${interface.sdim_param.upper()}$"] = [str(sdim_value)]
        
        # Datatype parameter assignments (generated at template time)
        from qonnx.core.datatype import DataType
        # Interface s_axis_input width parameter
        code_gen_dict["$INPUT_WIDTH$"] = [str(DataType[self.get_nodeattr("input0DataType")].bitwidth())]
        # Interface s_axis_weights width parameter
        code_gen_dict["$WEIGHT_WIDTH$"] = [str(DataType[self.get_nodeattr("weight0DataType")].bitwidth())]
        # Interface s_axis_weights signed parameter
        code_gen_dict["$WEIGHT_SIGNED$"] = [str(1 if DataType[self.get_nodeattr("weight0DataType")].signed() else 0)]
        # Interface m_axis_output width parameter
        code_gen_dict["$M_AXIS_OUTPUT_WIDTH$"] = [str(DataType[self.get_nodeattr("output0DataType")].bitwidth())]
        # Interface m_axis_output signed parameter
        code_gen_dict["$M_AXIS_OUTPUT_SIGNED$"] = [str(1 if DataType[self.get_nodeattr("output0DataType")].signed() else 0)]
        # Internal accumulator width parameter
        code_gen_dict["$ACC_WIDTH$"] = [str(DataType[self.get_nodeattr("accumulatorDataType")].bitwidth())]
        # Internal accumulator signed parameter
        code_gen_dict["$ACC_SIGNED$"] = [str(1 if DataType[self.get_nodeattr("accumulatorDataType")].signed() else 0)]
        # Internal threshold width parameter
        code_gen_dict["$THRESH_WIDTH$"] = [str(DataType[self.get_nodeattr("thresholdDataType")].bitwidth())]
        # Internal OUTPUT width parameter
        code_gen_dict["$OUTPUT_WIDTH$"] = [str(DataType[self.get_nodeattr("OUTPUTDataType")].bitwidth())]
        
        # Stream width parameters from DataflowModel
        dataflow_model = self.get_dataflow_model()
        if dataflow_model:
            for iface_name, iface in dataflow_model.interfaces.items():
                # Calculate stream width for this interface
                stream_width = iface.calculate_stream_width()
                # Generate template variable using original interface name (uppercase)
                template_var = f"${iface.name.upper()}_STREAM_WIDTH$"
                code_gen_dict[template_var] = [str(stream_width)]
        
        return code_gen_dict
    
    def get_supporting_rtl_files(self) -> list:
        """Get list of supporting RTL files to include."""
        return [
            "test_kernel_e2e_axi.sv",
            "test_kernel_e2e.sv",
        ]
    
    def lut_estimation(self) -> int:
        """Estimate LUT usage for test_kernel_e2e."""
        # TODO: Implement operation-specific LUT estimation
        # For now, use base class conservative estimate
        return super().lut_estimation()
    
    def bram_estimation(self) -> int:
        """Estimate BRAM usage for test_kernel_e2e."""
        # TODO: Implement operation-specific BRAM estimation
        # For now, use base class estimate
        return super().bram_estimation()
    
    def dsp_estimation(self, fpgapart) -> int:
        """Estimate DSP usage for test_kernel_e2e."""
        # TODO: Implement operation-specific DSP estimation
        # For now, use base class estimate
        return super().dsp_estimation(fpgapart)
    
    def get_verilog_top_module_intf_names(self):
        """Override to add AXI-Lite interface when configuration is enabled."""
        intf_names = super().get_verilog_top_module_intf_names()
        if self.get_nodeattr("axilite_config") == 1:
            intf_names["axilite"] = ["s_axilite_config"]
        return intf_names
