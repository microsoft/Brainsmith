"""
Enhanced HW Custom Op Generator.

This module provides an enhanced HW Custom Op generator that integrates with
the new Week 3 orchestration architecture while maintaining compatibility
with existing functionality.
"""

import time
from typing import Dict, Any, Optional, List, Union
from pathlib import Path

from ..enhanced_config import PipelineConfig, GeneratorType, DataflowMode
from ..enhanced_generator_base import GeneratorBase, GenerationResult, GeneratedArtifact
from ..enhanced_data_structures import RTLModule
from ..enhanced_template_context import EnhancedTemplateContextBuilder, HWCustomOpContext
from ..enhanced_template_manager import EnhancedTemplateManager
from ..errors import CodeGenerationError, ValidationError, TemplateError
from ..orchestration.generator_factory import GeneratorCapability


class EnhancedHWCustomOpGenerator(GeneratorBase):
    """
    Enhanced HW Custom Op generator with dataflow integration.
    
    This generator creates optimized HW Custom Op implementations that integrate
    with the AutoHWCustomOp base class and dataflow modeling system.
    """
    
    def __init__(self, config: PipelineConfig):
        super().__init__(config)
        self.template_manager = EnhancedTemplateManager(config.template)
        self.context_builder = EnhancedTemplateContextBuilder(config)
        
        # Generator metadata
        self.capabilities = {
            GeneratorCapability.HW_CUSTOM_OP,
            GeneratorCapability.DATAFLOW_INTEGRATION,
            GeneratorCapability.VALIDATION
        }
        
        # Performance tracking
        self._generation_count = 0
        self._total_generation_time = 0.0
        self._template_cache_hits = 0
    
    def get_template_name(self) -> str:
        """Get the primary template name for this generator."""
        if self.config.generation.use_autogenerated_base_classes:
            return "hw_custom_op_slim.py.j2"
        else:
            return "hw_custom_op.py.j2"
    
    def get_artifact_type(self) -> str:
        """Get the artifact type produced by this generator."""
        return "hwcustomop"
    
    def get_capabilities(self) -> set:
        """Get generator capabilities."""
        return self.capabilities
    
    def validate_inputs(self, inputs: Dict[str, Any]) -> List[str]:
        """Validate generator inputs."""
        errors = []
        
        # Check for required inputs
        if "rtl_module" not in inputs and "hw_kernel" not in inputs:
            errors.append("Missing required input: 'rtl_module' or 'hw_kernel'")
        
        # Validate RTL module if provided
        if "rtl_module" in inputs:
            rtl_module = inputs["rtl_module"]
            if not isinstance(rtl_module, RTLModule):
                errors.append(f"Invalid rtl_module type: {type(rtl_module)}")
            elif not rtl_module.interfaces:
                errors.append("RTL module has no interfaces")
        
        # Validate configuration
        if "config" in inputs:
            config = inputs["config"]
            if not isinstance(config, PipelineConfig):
                errors.append(f"Invalid config type: {type(config)}")
        
        return errors
    
    def generate(self, inputs: Dict[str, Any]) -> GenerationResult:
        """Generate HW Custom Op implementation."""
        start_time = time.time()
        result = GenerationResult(success=True)
        
        try:
            # Validate inputs
            validation_errors = self.validate_inputs(inputs)
            if validation_errors:
                for error in validation_errors:
                    result.add_error(error)
                return result
            
            # Extract and prepare inputs
            rtl_module = self._extract_rtl_module(inputs)
            config = inputs.get("config", self.config)
            
            # Build template context
            context = self._build_template_context(rtl_module, inputs)
            
            # Generate artifact
            artifact = self._generate_hw_custom_op_artifact(context, inputs)
            result.add_artifact(artifact)
            
            # Add generation metadata
            generation_time = time.time() - start_time
            self._update_generation_metrics(generation_time, True)
            
            result.metadata.update({
                "generator": "enhanced_hw_custom_op",
                "generation_time": generation_time,
                "template_used": self.get_template_name(),
                "dataflow_enabled": config.dataflow.mode != DataflowMode.DISABLED,
                "slim_mode": config.generation.use_autogenerated_base_classes,
                "capabilities": [cap.value for cap in self.capabilities]
            })
            
            return result
            
        except Exception as e:
            generation_time = time.time() - start_time
            self._update_generation_metrics(generation_time, False)
            
            result.add_error(f"HW Custom Op generation failed: {e}")
            result.success = False
            return result
    
    def _extract_rtl_module(self, inputs: Dict[str, Any]) -> RTLModule:
        """Extract RTL module from inputs."""
        if "rtl_module" in inputs:
            return inputs["rtl_module"]
        elif "hw_kernel" in inputs:
            # Convert HWKernel to RTLModule if needed
            hw_kernel = inputs["hw_kernel"]
            if isinstance(hw_kernel, RTLModule):
                return hw_kernel
            else:
                # Convert HWKernel to RTLModule
                return self._hw_kernel_to_rtl_module(hw_kernel)
        else:
            raise ValidationError("No RTL module or HW kernel provided")
    
    def _hw_kernel_to_rtl_module(self, hw_kernel: Any) -> RTLModule:
        """Convert HWKernel to RTLModule."""
        try:
            # Extract relevant fields from HWKernel
            return RTLModule(
                name=getattr(hw_kernel, 'module_name', 'unknown_module'),
                interfaces=getattr(hw_kernel, 'interfaces', []),
                parameters=getattr(hw_kernel, 'parameters', {}),
                source_file=getattr(hw_kernel, 'source_file', None)
            )
        except Exception as e:
            raise ValidationError(f"Failed to convert HWKernel to RTLModule: {e}")
    
    def _build_template_context(self, rtl_module: RTLModule, inputs: Dict[str, Any]) -> HWCustomOpContext:
        """Build template context for HW Custom Op generation."""
        try:
            # Use enhanced context builder
            context = self.context_builder.build_hwcustomop_context(
                rtl_module=rtl_module,
                config=self.config,
                analysis_results=inputs.get("analysis_results"),
                onnx_metadata=inputs.get("onnx_metadata"),
                custom_metadata=inputs.get("custom_metadata", {})
            )
            
            # Add generator-specific context
            context.custom_data.update({
                "class_name": inputs.get("class_name"),
                "source_file": inputs.get("source_file", "unknown.sv"),
                "include_debug_info": self.config.generation.include_debug_info,
                "include_type_hints": self.config.generation.include_type_hints,
                "slim_mode": self.config.generation.use_autogenerated_base_classes
            })
            
            return context
            
        except Exception as e:
            raise TemplateError(f"Failed to build template context: {e}")
    
    def _generate_hw_custom_op_artifact(
        self, 
        context: HWCustomOpContext, 
        inputs: Dict[str, Any]
    ) -> GeneratedArtifact:
        """Generate the HW Custom Op artifact."""
        try:
            # Render template
            template_name = self.get_template_name()
            content = self.template_manager.render_template(
                template_name=template_name,
                context=context.to_dict(),
                generator_type=GeneratorType.AUTO_HW_CUSTOM_OP
            )
            
            # Determine output file name
            class_name = inputs.get("class_name", context.rtl_module.name)
            file_name = f"{class_name}.py"
            
            # Create artifact
            artifact = GeneratedArtifact(
                file_name=file_name,
                content=content,
                artifact_type=self.get_artifact_type(),
                metadata={
                    "class_name": class_name,
                    "module_name": context.rtl_module.name,
                    "template_name": template_name,
                    "interface_count": len(context.rtl_module.interfaces),
                    "parameter_count": len(context.rtl_module.parameters),
                    "dataflow_enabled": context.config_metadata.get("dataflow_enabled", False),
                    "slim_mode": context.custom_data.get("slim_mode", False),
                    "generation_timestamp": time.time()
                }
            )
            
            # Validate artifact if enabled
            if self.config.generation.generate_enhanced_validation:
                self._validate_artifact(artifact, context)
            
            return artifact
            
        except TemplateError:
            raise
        except Exception as e:
            raise CodeGenerationError(
                f"Failed to generate HW Custom Op artifact: {e}",
                generator_type="enhanced_hw_custom_op",
                template_name=template_name
            )
    
    def _validate_artifact(self, artifact: GeneratedArtifact, context: HWCustomOpContext) -> None:
        """Validate generated artifact."""
        try:
            # Basic content validation
            if not artifact.content.strip():
                raise ValidationError("Generated artifact is empty")
            
            # Check for required Python syntax elements
            required_elements = ["class", "def", "import"]
            for element in required_elements:
                if element not in artifact.content:
                    artifact.metadata["warnings"] = artifact.metadata.get("warnings", [])
                    artifact.metadata["warnings"].append(f"Missing expected element: {element}")
            
            # Validate class name if specified
            class_name = context.custom_data.get("class_name")
            if class_name and f"class {class_name}" not in artifact.content:
                artifact.metadata["warnings"] = artifact.metadata.get("warnings", [])
                artifact.metadata["warnings"].append(f"Expected class name '{class_name}' not found")
            
            # Check for interface integration
            if context.rtl_module.interfaces:
                interface_names = [iface.name for iface in context.rtl_module.interfaces]
                interface_mentions = sum(1 for name in interface_names if name in artifact.content)
                if interface_mentions == 0:
                    artifact.metadata["warnings"] = artifact.metadata.get("warnings", [])
                    artifact.metadata["warnings"].append("No interface names found in generated code")
            
        except Exception as e:
            # Don't fail generation for validation errors, just log them
            artifact.metadata["validation_errors"] = [str(e)]
    
    def _update_generation_metrics(self, generation_time: float, success: bool) -> None:
        """Update generation performance metrics."""
        self._generation_count += 1
        self._total_generation_time += generation_time
        
        if not success:
            self.capabilities.add(GeneratorCapability.ERROR_RECOVERY)
    
    def get_performance_metrics(self) -> Dict[str, Any]:
        """Get generator performance metrics."""
        avg_time = (
            self._total_generation_time / self._generation_count 
            if self._generation_count > 0 else 0.0
        )
        
        return {
            "generation_count": self._generation_count,
            "total_generation_time": self._total_generation_time,
            "average_generation_time": avg_time,
            "template_cache_hits": self._template_cache_hits,
            "cache_hit_rate": (
                self._template_cache_hits / self._generation_count 
                if self._generation_count > 0 else 0.0
            )
        }
    
    def clear_cache(self) -> None:
        """Clear generator-specific caches."""
        if hasattr(self.template_manager, 'clear_cache'):
            self.template_manager.clear_cache()
    
    def get_supported_templates(self) -> List[str]:
        """Get list of supported templates."""
        return [
            "hw_custom_op_slim.py.j2",
            "hw_custom_op.py.j2",
            "hw_custom_op_dataflow.py.j2"
        ]
    
    def supports_dataflow_mode(self) -> bool:
        """Check if generator supports dataflow mode."""
        return GeneratorCapability.DATAFLOW_INTEGRATION in self.capabilities
    
    def get_configuration_requirements(self) -> Dict[str, Any]:
        """Get configuration requirements for this generator."""
        return {
            "required_config_sections": ["template", "generation", "dataflow"],
            "required_templates": self.get_supported_templates(),
            "required_capabilities": [cap.value for cap in self.capabilities],
            "optional_inputs": [
                "class_name", "source_file", "onnx_metadata", 
                "analysis_results", "custom_metadata"
            ],
            "output_artifacts": [self.get_artifact_type()]
        }


# Factory function for backward compatibility
def create_enhanced_hw_custom_op_generator(config: PipelineConfig) -> EnhancedHWCustomOpGenerator:
    """Create enhanced HW Custom Op generator."""
    return EnhancedHWCustomOpGenerator(config)


# Legacy compatibility wrapper
def generate_enhanced_hwcustomop(
    rtl_module: RTLModule,
    config: PipelineConfig,
    class_name: Optional[str] = None,
    source_file: str = "unknown.sv",
    **kwargs
) -> GenerationResult:
    """
    Legacy-compatible function interface for HW Custom Op generation.
    
    This function provides a backward-compatible interface while using
    the enhanced generator implementation.
    """
    generator = EnhancedHWCustomOpGenerator(config)
    
    inputs = {
        "rtl_module": rtl_module,
        "config": config,
        "class_name": class_name,
        "source_file": source_file,
        **kwargs
    }
    
    return generator.generate(inputs)