{#-
Unified HWKG HWCustomOp Instantiation Template

This template generates minimal HWCustomOp classes that instantiate AutoHWCustomOp
with DataflowModel-derived interface metadata, eliminating the need for complex
template-generated implementation code.

Key Features:
- Simple instantiation of AutoHWCustomOp with interface metadata
- DataflowModel-powered mathematical foundation (no placeholders)
- Runtime dimension extraction and performance calculation
- Full compatibility with FINN compiler workflow

This implements the unified architecture where templates instantiate rather than generate.
-#}
############################################################################
# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.
#
# AUTO-GENERATED: {{ class_name }}HWCustomOp for {{ kernel_name }}
# Generated: {{ generation_timestamp }}
# Generator: Unified HWKG with Interface-Wise Dataflow Modeling
#
# DATAFLOW-MODEL-POWERED HARDWARE COMPONENT
# This HWCustomOp uses DataflowModel for mathematical foundation.
# All performance calculations are mathematically derived, not placeholders.
############################################################################

import numpy as np
from typing import Dict, Any, List, Optional

# Import unified dataflow components
from {{ import_paths.auto_hw_custom_op }} import AutoHWCustomOp
from {{ import_paths.interface_metadata }} import create_interface_metadata
from {{ import_paths.dataflow_interface }} import DataflowInterfaceType

# Import FINN components
from qonnx.core.datatype import DataType


class {{ class_name }}HWCustomOp(AutoHWCustomOp):
    """
    Auto-generated HWCustomOp for {{ kernel_name }} kernel.
    
    This class uses the unified HWKG approach with Interface-Wise Dataflow Modeling:
    - DataflowModel provides mathematical foundation for all calculations
    - No placeholders or mocks - all methods have real implementations
    - Runtime dimension extraction from ONNX model when available
    - Automatic performance and resource analysis
    
    Interfaces ({{ dataflow_model_summary.num_interfaces }} total):
    {% for interface in interfaces -%}
    - {{ interface.name }}: {{ interface.interface_type }} ({{ interface.dtype_constraint.finn_type }})
    {% endfor %}
    """
    
    def __init__(self, onnx_node, **kwargs):
        """
        Initialize {{ class_name }}HWCustomOp with DataflowModel-based interface metadata.
        
        This uses the simplified 3-tier architecture:
        - Tier 1 (Kernel Data): Interface metadata from RTL parsing
        - Tier 2 (Model Data): Tensor shapes from ONNX when available  
        - Tier 3 (Parallelism): Runtime parallelism configuration
        """
        
        # Create interface metadata using unified RTL integration
        interface_metadata = [
            {% for interface in interfaces %}
            create_interface_metadata(
                name="{{ interface.name }}",
                interface_type="{{ interface.interface_type }}",
                chunking_strategy={
                    'type': '{{ interface.chunking_strategy.type }}',
                    'tensor_dims': {{ interface.chunking_strategy.tensor_dims }},
                    'block_dims': {{ interface.chunking_strategy.block_dims }}
                },
                dtype_constraints={
                    'finn_type': '{{ interface.dtype_constraint.finn_type }}',
                    'base_type': '{{ interface.dtype_constraint.base_type }}',
                    'bitwidth': {{ interface.dtype_constraint.bitwidth }},
                    'signed': {{ interface.dtype_constraint.signed | lower }}
                },
                axi_metadata={
                    'protocol': 'axi_stream',
                    'data_width': {{ interface.dtype_constraint.bitwidth }}
                }
            ),
            {% endfor %}
        ]
        
        # Initialize AutoHWCustomOp with interface metadata
        # The base class handles DataflowModel creation and mathematical calculations
        super().__init__(onnx_node, interface_metadata, **kwargs)
    
    def get_nodeattr_types(self) -> Dict[str, Any]:
        """
        Get node attribute types with dataflow enhancements.
        
        Uses AutoHWCustomOp's enhanced attribute system with mathematical
        foundation rather than placeholder values.
        """
        # Get enhanced attributes from AutoHWCustomOp base class
        attrs = super().get_enhanced_nodeattr_types()
        
        # Add kernel-specific attributes if needed
        kernel_specific_attrs = {
            # Add any {{ kernel_name }}-specific attributes here
            "kernel_name": ("s", False, "{{ kernel_name }}"),
            "generation_method": ("s", False, "unified_hwkg_dataflow_modeling"),
        }
        
        attrs.update(kernel_specific_attrs)
        return attrs
    
    # All other methods (get_exp_cycles, get_instream_width, etc.) are inherited
    # from AutoHWCustomOp and use the DataflowModel for mathematical calculations.
    # No placeholder implementations needed!
    
    def derive_characteristic_fxns(self) -> Dict[str, Any]:
        """
        Derive characteristic functions using DataflowModel.
        
        This overrides the base implementation to add any {{ kernel_name }}-specific
        characteristics while maintaining the mathematical foundation.
        """
        # Get base characteristics from DataflowModel
        base_characteristics = super().derive_characteristic_fxns()
        
        # Add kernel-specific characteristics
        kernel_characteristics = {
            "kernel_type": "{{ kernel_name }}",
            "dataflow_model_interfaces": {{ dataflow_model_summary.num_interfaces }},
            "unified_hwkg_generated": True,
        }
        
        base_characteristics.update(kernel_characteristics)
        return base_characteristics


# Factory function for easy instantiation
def create_{{ kernel_name }}_hwcustomop(onnx_node, **kwargs) -> {{ class_name }}HWCustomOp:
    """
    Factory function for creating {{ class_name }}HWCustomOp instances.
    
    Args:
        onnx_node: ONNX node for this operation
        **kwargs: Additional arguments
        
    Returns:
        {{ class_name }}HWCustomOp: Configured HWCustomOp instance
    """
    return {{ class_name }}HWCustomOp(onnx_node, **kwargs)


# Export the main class for FINN integration
__all__ = ["{{ class_name }}HWCustomOp", "create_{{ kernel_name }}_hwcustomop"]