{#-
Unified HWKG RTLBackend Instantiation Template

This template generates minimal RTLBackend classes that instantiate AutoRTLBackend
with DataflowModel-derived interface configuration, providing RTL generation
capabilities with mathematical foundation.

Key Features:
- Simple instantiation of AutoRTLBackend with dataflow interfaces
- DataflowModel-powered RTL parameter generation
- Automatic signal assignments and interface definitions
- Full compatibility with FINN RTL backend workflow

This implements the unified architecture for RTL backend generation.
-#}
############################################################################
# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.
#
# AUTO-GENERATED: {{ class_name }}RTLBackend for {{ kernel_name }}
# Generated: {{ generation_timestamp }}
# Generator: Unified HWKG with Interface-Wise Dataflow Modeling
#
# DATAFLOW-MODEL-POWERED RTL BACKEND
# This RTLBackend uses DataflowModel for interface configuration and
# RTL parameter generation with mathematical foundation.
############################################################################

import os
import numpy as np
from typing import Dict, Any, List, Optional

# Import unified dataflow components
from {{ import_paths.auto_rtl_backend }} import AutoRTLBackend
from {{ import_paths.dataflow_interface }} import DataflowInterfaceType

# Try to import FINN components (optional for development)
try:
    from finn.custom_op.fpgadataflow.rtlbackend import RTLBackend
    from qonnx.core.datatype import DataType
    FINN_AVAILABLE = True
except ImportError:
    FINN_AVAILABLE = False
    # Create stub base class for development
    class RTLBackend:
        def __init__(self):
            pass


class {{ class_name }}RTLBackend(AutoRTLBackend):
    """
    Auto-generated RTLBackend for {{ kernel_name }} kernel.
    
    This class uses the unified HWKG approach with Interface-Wise Dataflow Modeling:
    - AutoRTLBackend provides mathematical foundation for RTL generation
    - DataflowModel-driven interface configuration and parameter generation
    - Automatic signal assignments and wrapper generation
    - Runtime-configurable RTL parameters
    
    Interfaces ({{ dataflow_model_summary.num_interfaces }} total):
    {% for interface in interfaces -%}
    - {{ interface.name }}: {{ interface.interface_type }} ({{ interface.dtype_config.finn_type }}, {{ interface.axi_metadata.data_width }} bits)
    {% endfor %}
    """
    
    def __init__(self):
        """
        Initialize {{ class_name }}RTLBackend with DataflowModel-based interface configuration.
        
        The AutoRTLBackend base class provides all RTL generation capabilities
        using the dataflow interfaces configuration.
        """
        super().__init__()
        
        # Set dataflow interfaces configuration for AutoRTLBackend
        self.dataflow_interfaces = {
            {% for interface in interfaces %}
            "{{ interface.name }}": {
                "interface_type": "{{ interface.interface_type }}",
                "dtype": {
                    "finn_type": "{{ interface.dtype_config.finn_type }}",
                    "signed": {{ interface.dtype_config.signed | lower }},
                    "bitwidth": {{ interface.dtype_config.bitwidth }}
                },
                "tensor_dims": {{ interface.tensor_dims }},
                "block_dims": {{ interface.block_dims }},
                "stream_dims": {{ interface.stream_dims }},
                "axi_metadata": {
                    "protocol": "{{ interface.axi_metadata.protocol }}",
                    "data_width": {{ interface.axi_metadata.data_width }}
                }
            },
            {% endfor %}
        }
    
    def get_nodeattr_types(self) -> Dict[str, Any]:
        """
        Get node attribute types with RTL backend enhancements.
        
        Uses AutoRTLBackend's enhanced attribute system with dataflow
        interface configuration.
        """
        # Get enhanced attributes from AutoRTLBackend base class
        attrs = super().get_enhanced_nodeattr_types()
        
        # Add kernel-specific RTL configuration
        rtl_specific_attrs = {
            # RTL module configuration
            "rtl_module_name": ("s", False, "{{ kernel_name }}"),
            "wrapper_module_name": ("s", False, "{{ kernel_name }}_wrapper"),
            
            # Generation configuration
            "generation_method": ("s", False, "unified_hwkg_dataflow_modeling"),
            "kernel_type": ("s", False, "{{ kernel_name }}"),
        }
        
        attrs.update(rtl_specific_attrs)
        return attrs
    
    def code_generation_dict(self) -> Dict[str, Any]:
        """
        Generate RTL code generation dictionary using DataflowModel.
        
        This uses AutoRTLBackend's enhanced code generation with
        dataflow interface metadata.
        """
        # Get enhanced code generation dict from AutoRTLBackend
        codegen_dict = super().generate_enhanced_code_dict()
        
        # Add kernel-specific RTL generation parameters
        kernel_specific_params = {
            "kernel_name": "{{ kernel_name }}",
            "module_name": self.get_nodeattr("rtl_module_name") or "{{ kernel_name }}",
            "wrapper_name": self.get_nodeattr("wrapper_module_name") or "{{ kernel_name }}_wrapper",
            
            # Interface-specific parameters for RTL generation
            "interface_count": {{ dataflow_model_summary.num_interfaces }},
            "input_interface_count": {{ dataflow_model_summary.input_count }},
            "output_interface_count": {{ dataflow_model_summary.output_count }},
            "weight_interface_count": {{ dataflow_model_summary.weight_count }},
            
            # Add interface-specific RTL parameters
            {% for interface in interfaces %}
            "{{ interface.name }}_width": {{ interface.axi_metadata.data_width }},
            "{{ interface.name }}_type": "{{ interface.interface_type }}",
            {% endfor %}
        }
        
        codegen_dict.update(kernel_specific_params)
        return codegen_dict
    
    # All RTL generation methods (generate_params, etc.) are inherited from
    # AutoRTLBackend and use the dataflow interfaces configuration.
    # No placeholder implementations needed!
    
    def generate_rtl_wrapper(self, model, path: str) -> str:
        """
        Generate RTL wrapper using DataflowModel interface information.
        
        This uses AutoRTLBackend's wrapper generation with the dataflow
        interface configuration for accurate signal assignments.
        """
        # Use base class wrapper generation with our interface configuration
        wrapper_file = super().generate_params(model, path)
        
        # Log successful wrapper generation
        if hasattr(self, '_log_wrapper_generation'):
            self._log_wrapper_generation("{{ kernel_name }}", wrapper_file)
        
        return wrapper_file


# Factory function for easy instantiation
def create_{{ kernel_name }}_rtlbackend() -> {{ class_name }}RTLBackend:
    """
    Factory function for creating {{ class_name }}RTLBackend instances.
    
    Returns:
        {{ class_name }}RTLBackend: Configured RTLBackend instance
    """
    return {{ class_name }}RTLBackend()


# Export the main class for FINN integration
__all__ = ["{{ class_name }}RTLBackend", "create_{{ kernel_name }}_rtlbackend"]