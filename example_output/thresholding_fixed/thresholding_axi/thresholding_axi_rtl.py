# Auto-generated by Brainsmith Hardware Kernel Generator
# Generated from: brainsmith/hw_kernels/thresholding/thresholding_axi.sv
# Date: 2025-06-16T22:40:14.946360

from finn.custom_op.fpgadataflow.thresholding import Thresholding
from brainsmith.dataflow.core.auto_rtl_backend import AutoRTLBackend
from qonnx.core.datatype import DataType
from brainsmith.dataflow.core.auto_rtl_backend import AdvancedMemoryMixin


class thresholding_axi_rtl(Thresholding, AdvancedMemoryMixin, AutoRTLBackend):
    """RTL backend for thresholding_axi operation.
    
    Auto-generated from SystemVerilog RTL analysis.
    
    Multi-threshold activation function with configurable thresholds and output encoding.
    """
    
    def __init__(self, onnx_node, **kwargs):
        super().__init__(onnx_node, **kwargs)
    
    @property
    def finn_rtllib_module(self) -> str:
        """Return finn-rtllib module name for this operation."""
        return "thresholding"
    
    def get_nodeattr_types(self):
        """Get node attribute types for RTLBackend (algorithm parameters only)."""
        my_attrs = {}
        
        # Only expose algorithm parameters, NOT datatype-linked parameters
        # Algorithm parameter - optional with default
        my_attrs["N"] = ("i", False, 1)
        # Algorithm parameter - optional with default
        my_attrs["WT"] = ("i", False, 1)
        # Algorithm parameter - optional with default
        my_attrs["C"] = ("i", False, 1)
        # Algorithm parameter - optional with default
        my_attrs["PE"] = ("i", False, 1)
        # Algorithm parameter - optional with default
        my_attrs["THRESHOLDS_PATH"] = ("i", False, 1)
        # Algorithm parameter - optional with default
        my_attrs["USE_AXILITE"] = ("i", False, 1)
        # Algorithm parameter - optional with default
        my_attrs["DEPTH_TRIGGER_URAM"] = ("i", False, 1)
        # Algorithm parameter - optional with default
        my_attrs["DEPTH_TRIGGER_BRAM"] = ("i", False, 1)
        # Algorithm parameter - optional with default
        my_attrs["DEEP_PIPELINE"] = ("i", False, 1)
        
        # Merge with parent class attributes
        my_attrs.update(Thresholding.get_nodeattr_types(self))
        my_attrs.update(AutoRTLBackend.get_nodeattr_types(self))
        
        return my_attrs
    
    def prepare_codegen_rtl_values(self, model):
        """Prepare template variables for RTL code generation.
        
        All dictionary values produced in this function are to replace
        their key value(s) in the RTL template files following FINN's pattern.
        """
        code_gen_dict = {}
        
        # Basic module information
        code_gen_dict["$MODULE_NAME_AXI_WRAPPER$"] = [self.get_verilog_top_module_name()]
        code_gen_dict["$TOP_MODULE$"] = code_gen_dict["$MODULE_NAME_AXI_WRAPPER$"]
        
        # Standard stream width variables
        code_gen_dict["$IBITS$"] = [str(self.get_instream_width())]
        code_gen_dict["$OBITS$"] = [str(self.get_outstream_width())]
        
        # Algorithm parameters from node attributes
        code_gen_dict["$N$"] = [str(self.get_nodeattr("N"))]
        code_gen_dict["$WT$"] = [str(self.get_nodeattr("WT"))]
        code_gen_dict["$C$"] = [str(self.get_nodeattr("C"))]
        code_gen_dict["$PE$"] = [str(self.get_nodeattr("PE"))]
        code_gen_dict["$THRESHOLDS_PATH$"] = [str(self.get_nodeattr("THRESHOLDS_PATH"))]
        code_gen_dict["$USE_AXILITE$"] = [str(self.get_nodeattr("USE_AXILITE"))]
        code_gen_dict["$DEPTH_TRIGGER_URAM$"] = [str(self.get_nodeattr("DEPTH_TRIGGER_URAM"))]
        code_gen_dict["$DEPTH_TRIGGER_BRAM$"] = [str(self.get_nodeattr("DEPTH_TRIGGER_BRAM"))]
        code_gen_dict["$DEEP_PIPELINE$"] = [str(self.get_nodeattr("DEEP_PIPELINE"))]
        
        # Datatype-linked parameters computed on-demand
        # Input width from input datatype
        code_gen_dict["$WI$"] = [str(self.get_input_datatype().bitwidth())]
        # Floating point argument (0=integer, 1=float)
        code_gen_dict["$FPARG$"] = [str(0 if self.get_input_datatype().is_integer() else 1)]
        # Bias value if available from attributes
        bias = self.get_nodeattr("bias") if hasattr(self, "get_nodeattr") and "bias" in [attr for attr in dir(self) if "nodeattr" in attr] else 0
        code_gen_dict["$BIAS$"] = [str(bias)]
        # Input signedness
        code_gen_dict["$SIGNED$"] = [str(1 if self.get_input_datatype().signed() else 0)]
        # Output bits calculation depends on operation specifics
        output_bitwidth = self.get_output_datatype().bitwidth()
        code_gen_dict["$O_BITS$"] = [str(output_bitwidth)]
        
        return code_gen_dict
    
    def get_supporting_rtl_files(self) -> list:
        """Get list of supporting RTL files to include."""
        return [
            "thresholding_axi.sv",
            "thresholding.sv",
        ]
    
    def lut_estimation(self) -> int:
        """Estimate LUT usage for thresholding_axi."""
        # TODO: Implement operation-specific LUT estimation
        # For now, use base class conservative estimate
        return super().lut_estimation()
    
    def bram_estimation(self) -> int:
        """Estimate BRAM usage for thresholding_axi."""
        # TODO: Implement operation-specific BRAM estimation
        # For now, use base class estimate
        return super().bram_estimation()
    
    def dsp_estimation(self, fpgapart) -> int:
        """Estimate DSP usage for thresholding_axi."""
        # TODO: Implement operation-specific DSP estimation
        # For now, use base class estimate
        return super().dsp_estimation(fpgapart)
