{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Brainsmith","text":"<p>From PyTorch to RTL - FPGA Accelerator Compiler for AI</p> <p>Brainsmith automates design space exploration (DSE) and implementation of neural networks on FPGA, from PyTorch to RTL. It builds on FINN, QONNX, and Brevitas to create dataflow accelerators with tunable parameters.</p>"},{"location":"#pre-release","title":"Pre-Release","text":"<p>Pre-Release Status</p> <p>This repository is in a pre-release state and under active co-development by Microsoft and AMD.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Plugin System - Extensible architecture for registering custom kernels, transforms, and build steps</li> <li>Blueprint Interface - YAML-based declarative configuration with inheritance support</li> <li>Segment-based Execution - Efficient DSE through intelligent computation reuse</li> <li>BERT Demo - Example end-to-end acceleration (PyTorch to stitched-IP RTL)</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li> <p> Quick Start</p> <p>Get up and running in minutes</p> </li> <li> <p> Installation</p> <p>Set up your development environment</p> </li> <li> <p> Architecture</p> <p>Understand how Brainsmith works</p> </li> <li> <p> API Reference</p> <p>Explore the codebase</p> </li> </ul>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph LR\n    A[PyTorch Model] --&gt; B[Brevitas Quantization]\n    B --&gt; C[ONNX Export]\n    C --&gt; D[QONNX]\n    D --&gt; E[Brainsmith DSE]\n    E --&gt; F[FINN Dataflow]\n    F --&gt; G[RTL Generation]\n    G --&gt; H[Vivado Synthesis]\n    H --&gt; I[FPGA Bitstream]</code></pre>"},{"location":"#example-design-space-exploration","title":"Example: Design Space Exploration","text":"<pre><code># Run DSE with ONNX model and blueprint\nsmith model.onnx blueprint.yaml --output-dir ./results\n</code></pre>"},{"location":"#built-with","title":"Built With","text":"<p>Brainsmith builds upon:</p> <ul> <li>FINN - Dataflow compiler for quantized neural networks</li> <li>QONNX - Quantized ONNX representation</li> <li>Brevitas - PyTorch quantization library</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>Brainsmith is developed through a collaboration between Microsoft and AMD.</p>"},{"location":"404/","title":"Page Not Found","text":"<p>Oops! The page you're looking for doesn't exist.</p>"},{"location":"404/#what-happened","title":"What Happened?","text":"<p>The URL you entered or followed may be incorrect, or the page may have been moved or deleted.</p>"},{"location":"404/#what-can-you-do","title":"What Can You Do?","text":"<ul> <li> <p> Go to Home Page</p> <p>Return to the documentation home</p> </li> <li> <p> Browse Documentation</p> <p>Start with the installation guide</p> </li> <li> <p> Use the Search</p> <p>Try searching for what you need using the search bar above</p> </li> <li> <p> Report an Issue</p> <p>Found a broken link? Let us know</p> </li> </ul>"},{"location":"404/#popular-pages","title":"Popular Pages","text":"<ul> <li>Installation Guide</li> <li>Quick Start</li> <li>Architecture Overview</li> <li>API Reference</li> <li>Contributing Guide</li> </ul> <p>Need help? Check out our GitHub Discussions or open an issue.</p>"},{"location":"contributing/","title":"Contributing to Brainsmith","text":"<p>We welcome contributions! This guide will help you get started.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li>Fork the repository</li> <li>Clone your fork:    <pre><code>git clone https://github.com/YOUR_USERNAME/brainsmith.git\ncd brainsmith\n</code></pre></li> <li>Run setup:    <pre><code>./setup-venv.sh\nsource .venv/bin/activate\n</code></pre></li> <li>Configure Vivado paths:    <pre><code>brainsmith config init\n# Edit ~/.brainsmith/config.yaml\n</code></pre></li> </ol>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># All tests\npytest tests/\n\n# Specific test file\npytest tests/integration/test_plugin_system.py\n\n# With coverage\npytest tests/ --cov=brainsmith.core\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We use minimal linting rules during the alpha phase:</p> <pre><code># Check code\nruff check brainsmith/ tests/\n\n# Auto-fix issues\nruff check --fix brainsmith/ tests/\n\n# Format code\nruff format brainsmith/ tests/\n</code></pre>"},{"location":"contributing/#style-guidelines","title":"Style Guidelines","text":"<ul> <li>Line length: 100 characters</li> <li>Python 3.10+ required</li> <li>Docstring style: Google format preferred</li> </ul>"},{"location":"contributing/#making-changes","title":"Making Changes","text":"<ol> <li> <p>Create a feature branch:    <pre><code>git checkout -b feature/my-feature\n</code></pre></p> </li> <li> <p>Make your changes</p> </li> <li> <p>Add tests for new functionality</p> </li> <li> <p>Run tests and linting:    <pre><code>pytest tests/\nruff check brainsmith/ tests/\n</code></pre></p> </li> <li> <p>Commit with descriptive messages:    <pre><code>git commit -m \"Add feature X that does Y\"\n</code></pre></p> </li> <li> <p>Push to your fork:    <pre><code>git push origin feature/my-feature\n</code></pre></p> </li> <li> <p>Open a Pull Request on GitHub</p> </li> </ol>"},{"location":"contributing/#pr-guidelines","title":"PR Guidelines","text":"<ul> <li>Describe what your PR does and why</li> <li>Reference any related issues</li> <li>Ensure all tests pass</li> <li>Add documentation for new features</li> <li>Keep PRs focused and reasonably sized</li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>When adding features, update documentation:</p> <ul> <li>Add/update docstrings</li> <li>Update relevant markdown docs in <code>docs/</code></li> <li>Add examples if applicable</li> </ul> <p>Build docs locally:</p> <pre><code>mkdocs serve\n</code></pre> <p>Then open http://127.0.0.1:8000</p>"},{"location":"contributing/#questions","title":"Questions?","text":"<ul> <li>Open an issue</li> <li>Start a discussion</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please be respectful and follow our Code of Conduct.</p>"},{"location":"api-reference/core/","title":"Core API Reference","text":""},{"location":"api-reference/core/#brainsmith.core","title":"<code>core</code>","text":"<p>Brainsmith Core - DSE Architecture</p> <p>This package implements the DSE architecture for FPGA accelerator design.</p>"},{"location":"api-reference/core/#brainsmith.core.DSESegment","title":"<code>DSESegment(transforms: List[Dict[str, Any]], branch_choice: Optional[str] = None, parent: Optional[DSESegment] = None, children: Dict[str, DSESegment] = dict(), status: str = 'pending', output_dir: Optional[Path] = None, error: Optional[str] = None, execution_time: Optional[float] = None, artifacts: ArtifactState = ArtifactState(), finn_config: Dict[str, Any] = dict())</code>  <code>dataclass</code>","text":"<p>A segment in the design space exploration tree.</p> <p>Each segment is executed as a single FINN build, containing all transforms from the last branch point (or root) to the next branch point (or leaf).</p>"},{"location":"api-reference/core/#brainsmith.core.DSESegment.is_branch_point","title":"<code>is_branch_point: bool</code>  <code>property</code>","text":"<p>Check if this segment branches.</p>"},{"location":"api-reference/core/#brainsmith.core.DSESegment.is_leaf","title":"<code>is_leaf: bool</code>  <code>property</code>","text":"<p>Check if this is a complete path endpoint.</p>"},{"location":"api-reference/core/#brainsmith.core.DSESegment.segment_id","title":"<code>segment_id: str</code>  <code>property</code>","text":"<p>Deterministic ID from content.</p>"},{"location":"api-reference/core/#brainsmith.core.DSESegment.add_child","title":"<code>add_child(branch_id: str, transforms: List[Dict[str, Any]]) -&gt; DSESegment</code>","text":"<p>Create a child segment for a branch.</p>"},{"location":"api-reference/core/#brainsmith.core.DSESegment.count_descendants","title":"<code>count_descendants() -&gt; int</code>","text":"<p>Count total number of descendant nodes.</p>"},{"location":"api-reference/core/#brainsmith.core.DSESegment.get_all_transforms","title":"<code>get_all_transforms() -&gt; List[Dict[str, Any]]</code>","text":"<p>Get all transforms from root to end of this segment.</p>"},{"location":"api-reference/core/#brainsmith.core.DSESegment.get_cache_key","title":"<code>get_cache_key() -&gt; str</code>","text":"<p>Simple, deterministic cache key.</p>"},{"location":"api-reference/core/#brainsmith.core.DSESegment.get_path","title":"<code>get_path() -&gt; List[DSESegment]</code>","text":"<p>Get all segments from root to here.</p>"},{"location":"api-reference/core/#brainsmith.core.DSETree","title":"<code>DSETree(root: DSESegment)</code>","text":"<p>Design space exploration tree structure and operations.</p>"},{"location":"api-reference/core/#brainsmith.core.DSETree.count_leaves","title":"<code>count_leaves() -&gt; int</code>","text":"<p>Count leaf nodes in tree.</p>"},{"location":"api-reference/core/#brainsmith.core.DSETree.count_nodes","title":"<code>count_nodes() -&gt; int</code>","text":"<p>Count all nodes in tree.</p>"},{"location":"api-reference/core/#brainsmith.core.DSETree.get_all_segments","title":"<code>get_all_segments() -&gt; List[DSESegment]</code>","text":"<p>Get all segments in the tree.</p>"},{"location":"api-reference/core/#brainsmith.core.DSETree.get_execution_order","title":"<code>get_execution_order() -&gt; List[DSESegment]</code>","text":"<p>Get breadth-first execution order for the tree.</p> <p>This ensures parent nodes are executed before children, enabling proper result sharing.</p> <p>Returns:</p> Type Description <code>List[DSESegment]</code> <p>List of nodes in execution order</p>"},{"location":"api-reference/core/#brainsmith.core.DSETree.get_leaf_segments","title":"<code>get_leaf_segments() -&gt; List[DSESegment]</code>","text":"<p>Get all complete exploration paths (leaf segments).</p>"},{"location":"api-reference/core/#brainsmith.core.DSETree.get_statistics","title":"<code>get_statistics() -&gt; Dict[str, Any]</code>","text":"<p>Get statistics about the DSE tree.</p>"},{"location":"api-reference/core/#brainsmith.core.DSETree.print_tree","title":"<code>print_tree() -&gt; None</code>","text":"<p>Pretty print the DSE tree.</p>"},{"location":"api-reference/core/#brainsmith.core.DSETreeBuilder","title":"<code>DSETreeBuilder</code>","text":"<p>Builds DSE trees from design spaces.</p>"},{"location":"api-reference/core/#brainsmith.core.DSETreeBuilder.build_tree","title":"<code>build_tree(space: DesignSpace, forge_config: ForgeConfig) -&gt; DSETree</code>","text":"<p>Build DSE tree with unified branching.</p> <p>Steps can now be direct strings or lists for variations.</p> <p>Parameters:</p> Name Type Description Default <code>space</code> <code>DesignSpace</code> <p>DesignSpace containing steps and configuration</p> required <code>forge_config</code> <code>ForgeConfig</code> <p>ForgeConfig with FINN parameters</p> required <p>Returns:</p> Type Description <code>DSETree</code> <p>DSETree containing the built tree</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If tree exceeds max_combinations</p>"},{"location":"api-reference/core/#brainsmith.core.DesignSpace","title":"<code>DesignSpace(model_path: str, steps: List[Union[str, List[Optional[str]]]], kernel_backends: List[Tuple[str, List[Type]]], max_combinations: int = 100000)</code>  <code>dataclass</code>","text":"<p>Design space with resolved plugin objects.</p> <p>This is a clean intermediate representation between blueprint YAML and the execution tree. All plugin names have been resolved to actual classes from the registry.</p>"},{"location":"api-reference/core/#brainsmith.core.DesignSpace.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate steps after initialization.</p>"},{"location":"api-reference/core/#brainsmith.core.DesignSpace.__str__","title":"<code>__str__() -&gt; str</code>","text":"<p>Human-readable representation.</p>"},{"location":"api-reference/core/#brainsmith.core.DesignSpace.get_kernel_summary","title":"<code>get_kernel_summary() -&gt; str</code>","text":"<p>Get human-readable summary of kernels and backends.</p>"},{"location":"api-reference/core/#brainsmith.core.DesignSpace.validate_size","title":"<code>validate_size() -&gt; None</code>","text":"<p>Validate that design space doesn't exceed max combinations.</p>"},{"location":"api-reference/core/#brainsmith.core.DesignSpace.validate_steps","title":"<code>validate_steps() -&gt; None</code>","text":"<p>Validate that all referenced steps exist in the registry.</p>"},{"location":"api-reference/core/#brainsmith.core.ForgeConfig","title":"<code>ForgeConfig(clock_ns: float, output: Literal['estimates', 'rtl', 'bitfile'] = 'estimates', board: Optional[str] = None, verify: bool = False, verify_data: Optional[Path] = None, parallel_builds: int = 4, debug: bool = False, save_intermediate_models: bool = False, start_step: Optional[str] = None, stop_step: Optional[str] = None, finn_overrides: Dict[str, Any] = dict())</code>  <code>dataclass</code>","text":"<p>Configuration that actually works.</p>"},{"location":"api-reference/core/#brainsmith.core.SegmentRunner","title":"<code>SegmentRunner(finn_runner: FINNRunner, base_config: Dict[str, Any], kernel_selections: list = None)</code>","text":"<p>Runs DSE segments using FINN.</p> <p>Handles both tree traversal and individual segment execution using FINNRunner for all FINN interactions.</p> <p>Initialize runner.</p> <p>Parameters:</p> Name Type Description Default <code>finn_runner</code> <code>FINNRunner</code> <p>Runner for FINN-specific operations</p> required <code>base_config</code> <code>Dict[str, Any]</code> <p>FINN configuration from blueprint</p> required <code>kernel_selections</code> <code>list</code> <p>Optional list of (kernel, backend) tuples</p> <code>None</code>"},{"location":"api-reference/core/#brainsmith.core.SegmentRunner.run_segment","title":"<code>run_segment(segment: DSESegment, input_model: Path, base_output_dir: Path) -&gt; SegmentResult</code>","text":"<p>Run a single DSE segment.</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>DSESegment</code> <p>Segment to execute</p> required <code>input_model</code> <code>Path</code> <p>Input ONNX model path</p> required <code>base_output_dir</code> <code>Path</code> <p>Base output directory</p> required <p>Returns:</p> Type Description <code>SegmentResult</code> <p>SegmentResult with execution details</p>"},{"location":"api-reference/core/#brainsmith.core.SegmentRunner.run_tree","title":"<code>run_tree(tree: DSETree, initial_model: Path, output_dir: Path) -&gt; TreeExecutionResult</code>","text":"<p>Run all segments in the DSE tree.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>DSETree</code> <p>DSE tree to execute</p> required <code>initial_model</code> <code>Path</code> <p>Path to initial ONNX model</p> required <code>output_dir</code> <code>Path</code> <p>Base output directory</p> required <p>Returns:</p> Type Description <code>TreeExecutionResult</code> <p>TreeExecutionResult with all segment results</p>"},{"location":"api-reference/core/#brainsmith.core.explore_design_space","title":"<code>explore_design_space(model_path: str, blueprint_path: str, output_dir: str = None, start_step_override: str = None, stop_step_override: str = None)</code>","text":"<p>Explore the design space for an FPGA accelerator.</p> <p>Transforms a neural network model into an FPGA accelerator through blueprint-driven design space exploration and synthesis.</p> <p>Parameters:</p> Name Type Description Default <code>model_path</code> <code>str</code> <p>Path to ONNX model file</p> required <code>blueprint_path</code> <code>str</code> <p>Path to Blueprint YAML file</p> required <code>output_dir</code> <code>str</code> <p>Output directory (defaults to $BSMITH_BUILD_DIR/forge_YYYYMMDD_HHMMSS)</p> <code>None</code> <code>start_step_override</code> <code>str</code> <p>Override blueprint start_step (CLI takes precedence)</p> <code>None</code> <code>stop_step_override</code> <code>str</code> <p>Override blueprint stop_step (CLI takes precedence)</p> <code>None</code> <p>Returns:</p> Type Description <p>TreeExecutionResult containing build artifacts and statistics</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If model or blueprint file doesn't exist</p> <code>ValueError</code> <p>If blueprint is invalid or tree exceeds size limits</p> <code>RuntimeError</code> <p>If no successful builds were produced</p>"},{"location":"api-reference/core/#brainsmith.core.parse_blueprint","title":"<code>parse_blueprint(blueprint_path: str, model_path: str) -&gt; Tuple[DesignSpace, ForgeConfig]</code>","text":"<p>Parse blueprint YAML and return DesignSpace and ForgeConfig.</p> <p>Inheritance is resolved bottom-up: 1. Start from the root parent (no extends) 2. Fully resolve its steps (including operations) 3. Pass resolved steps to child for its operations 4. Repeat until we reach the target blueprint</p>"},{"location":"api-reference/core/#main-api","title":"Main API","text":""},{"location":"api-reference/core/#brainsmith.core.explore_design_space","title":"<code>explore_design_space(model_path: str, blueprint_path: str, output_dir: str = None, start_step_override: str = None, stop_step_override: str = None)</code>","text":"<p>Explore the design space for an FPGA accelerator.</p> <p>Transforms a neural network model into an FPGA accelerator through blueprint-driven design space exploration and synthesis.</p> <p>Parameters:</p> Name Type Description Default <code>model_path</code> <code>str</code> <p>Path to ONNX model file</p> required <code>blueprint_path</code> <code>str</code> <p>Path to Blueprint YAML file</p> required <code>output_dir</code> <code>str</code> <p>Output directory (defaults to $BSMITH_BUILD_DIR/forge_YYYYMMDD_HHMMSS)</p> <code>None</code> <code>start_step_override</code> <code>str</code> <p>Override blueprint start_step (CLI takes precedence)</p> <code>None</code> <code>stop_step_override</code> <code>str</code> <p>Override blueprint stop_step (CLI takes precedence)</p> <code>None</code> <p>Returns:</p> Type Description <p>TreeExecutionResult containing build artifacts and statistics</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If model or blueprint file doesn't exist</p> <code>ValueError</code> <p>If blueprint is invalid or tree exceeds size limits</p> <code>RuntimeError</code> <p>If no successful builds were produced</p> Source code in <code>brainsmith/core/dse_api.py</code> <pre><code>def explore_design_space(\n    model_path: str,\n    blueprint_path: str,\n    output_dir: str = None,\n    start_step_override: str = None,\n    stop_step_override: str = None\n):\n    \"\"\"\n    Explore the design space for an FPGA accelerator.\n\n    Transforms a neural network model into an FPGA accelerator through\n    blueprint-driven design space exploration and synthesis.\n\n    Args:\n        model_path: Path to ONNX model file\n        blueprint_path: Path to Blueprint YAML file\n        output_dir: Output directory (defaults to $BSMITH_BUILD_DIR/forge_YYYYMMDD_HHMMSS)\n        start_step_override: Override blueprint start_step (CLI takes precedence)\n        stop_step_override: Override blueprint stop_step (CLI takes precedence)\n\n    Returns:\n        TreeExecutionResult containing build artifacts and statistics\n\n    Raises:\n        FileNotFoundError: If model or blueprint file doesn't exist\n        ValueError: If blueprint is invalid or tree exceeds size limits\n        RuntimeError: If no successful builds were produced\n    \"\"\"\n    # Verify files exist\n    if not Path(model_path).exists():\n        raise FileNotFoundError(f\"Model file not found: {model_path}\")\n    if not Path(blueprint_path).exists():\n        raise FileNotFoundError(f\"Blueprint file not found: {blueprint_path}\")\n\n    # Determine output directory\n    if output_dir is None:\n        build_dir = get_build_dir()\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        output_dir = str(build_dir / f\"dse_{timestamp}\")\n\n    output_path = Path(output_dir)\n    output_path.mkdir(parents=True, exist_ok=True)\n\n    logger.info(f\"Exploring design space for FPGA accelerator:\")\n    logger.info(f\"  Model: {model_path}\")\n    logger.info(f\"  Blueprint: {blueprint_path}\")\n    logger.info(f\"  Output: {output_dir}\")\n\n    # Parse blueprint\n    design_space, forge_config = parse_blueprint(blueprint_path, str(Path(model_path).absolute()))\n\n    # Apply CLI overrides (CLI &gt; blueprint)\n    start_step = start_step_override or forge_config.start_step\n    stop_step = stop_step_override or forge_config.stop_step\n\n    # Slice steps if specified\n    if start_step or stop_step:\n        logger.info(f\"Applying step range: start={start_step or 'beginning'}, stop={stop_step or 'end'}\")\n        design_space.steps = slice_steps(design_space.steps, start_step, stop_step)\n\n    # Build DSE tree\n    tree_builder = DSETreeBuilder()\n    tree = tree_builder.build_tree(design_space, forge_config)\n\n    logger.info(f\"Design space: {len(design_space.steps)} steps, \"\n                f\"{len(design_space.kernel_backends)} kernels\")\n\n    # Log tree statistics\n    stats = tree.get_statistics()\n    logger.info(f\"DSE tree:\")\n    logger.info(f\"  - Total paths: {stats['total_paths']:,}\")\n    logger.info(f\"  - Total segments: {stats['total_segments']:,}\")\n    logger.info(f\"  - Segment efficiency: {stats['segment_efficiency']}%\")\n\n    # Explore the DSE tree\n    logger.info(\"Starting design space exploration...\")\n\n    # Create runner and execute\n    finn_runner = FINNRunner()\n    runner = SegmentRunner(finn_runner, tree.root.finn_config)\n    results = runner.run_tree(\n        tree=tree,\n        initial_model=Path(model_path),\n        output_dir=Path(output_dir)\n    )\n\n    # Check results\n    result_stats = results.stats\n\n    # Consider both successful and cached builds as valid outcomes\n    valid_builds = result_stats['successful'] + result_stats['cached']\n\n    if valid_builds == 0:\n        raise RuntimeError(f\"DSE failed: No successful builds \"\n                         f\"({result_stats['failed']} failed, {result_stats['skipped']} skipped)\")\n\n    # Warn if only cached results were used\n    if result_stats['successful'] == 0 and result_stats['cached'] &gt; 0:\n        logger.warning(f\"\u26a0\ufe0f  All builds used cached results ({result_stats['cached']} cached). \"\n                      f\"No new builds were executed.\")\n\n    logger.info(f\"\u2705 Design space exploration completed successfully!\")\n    logger.info(f\"   Successful builds: {result_stats['successful']}/{result_stats['total']}\")\n    logger.info(f\"   Total time: {results.total_time:.2f}s\")\n    logger.info(f\"   Output directory: {output_dir}\")\n\n    # Attach design space and tree to results for inspection\n    results.design_space = design_space\n    results.dse_tree = tree\n\n    return results\n</code></pre>"},{"location":"api-reference/core/#dse-components","title":"DSE Components","text":""},{"location":"api-reference/core/#brainsmith.core.DSESegment","title":"<code>DSESegment(transforms: List[Dict[str, Any]], branch_choice: Optional[str] = None, parent: Optional[DSESegment] = None, children: Dict[str, DSESegment] = dict(), status: str = 'pending', output_dir: Optional[Path] = None, error: Optional[str] = None, execution_time: Optional[float] = None, artifacts: ArtifactState = ArtifactState(), finn_config: Dict[str, Any] = dict())</code>  <code>dataclass</code>","text":"<p>A segment in the design space exploration tree.</p> <p>Each segment is executed as a single FINN build, containing all transforms from the last branch point (or root) to the next branch point (or leaf).</p>"},{"location":"api-reference/core/#brainsmith.core.DSESegment.is_branch_point","title":"<code>is_branch_point: bool</code>  <code>property</code>","text":"<p>Check if this segment branches.</p>"},{"location":"api-reference/core/#brainsmith.core.DSESegment.is_leaf","title":"<code>is_leaf: bool</code>  <code>property</code>","text":"<p>Check if this is a complete path endpoint.</p>"},{"location":"api-reference/core/#brainsmith.core.DSESegment.segment_id","title":"<code>segment_id: str</code>  <code>property</code>","text":"<p>Deterministic ID from content.</p>"},{"location":"api-reference/core/#brainsmith.core.DSESegment.add_child","title":"<code>add_child(branch_id: str, transforms: List[Dict[str, Any]]) -&gt; DSESegment</code>","text":"<p>Create a child segment for a branch.</p> Source code in <code>brainsmith/core/dse/segment.py</code> <pre><code>def add_child(self, branch_id: str, transforms: List[Dict[str, Any]]) -&gt; 'DSESegment':\n    \"\"\"Create a child segment for a branch.\"\"\"\n    child = DSESegment(\n        transforms=transforms,\n        branch_choice=branch_id,\n        parent=self,\n        finn_config=self.finn_config.copy()\n    )\n    self.children[branch_id] = child\n    return child\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.DSESegment.count_descendants","title":"<code>count_descendants() -&gt; int</code>","text":"<p>Count total number of descendant nodes.</p> Source code in <code>brainsmith/core/dse/segment.py</code> <pre><code>def count_descendants(self) -&gt; int:\n    \"\"\"Count total number of descendant nodes.\"\"\"\n    count = len(self.children)\n    for child in self.children.values():\n        count += child.count_descendants()\n    return count\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.DSESegment.get_all_transforms","title":"<code>get_all_transforms() -&gt; List[Dict[str, Any]]</code>","text":"<p>Get all transforms from root to end of this segment.</p> Source code in <code>brainsmith/core/dse/segment.py</code> <pre><code>def get_all_transforms(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get all transforms from root to end of this segment.\"\"\"\n    transforms = []\n    for segment in self.get_path():\n        transforms.extend(segment.transforms)\n    return transforms\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.DSESegment.get_cache_key","title":"<code>get_cache_key() -&gt; str</code>","text":"<p>Simple, deterministic cache key.</p> Source code in <code>brainsmith/core/dse/segment.py</code> <pre><code>def get_cache_key(self) -&gt; str:\n    \"\"\"Simple, deterministic cache key.\"\"\"\n    return self.segment_id\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.DSESegment.get_path","title":"<code>get_path() -&gt; List[DSESegment]</code>","text":"<p>Get all segments from root to here.</p> Source code in <code>brainsmith/core/dse/segment.py</code> <pre><code>def get_path(self) -&gt; List['DSESegment']:\n    \"\"\"Get all segments from root to here.\"\"\"\n    path = []\n    node = self\n    while node:\n        path.append(node)\n        node = node.parent\n    path.reverse()\n    return path\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.DSETree","title":"<code>DSETree(root: DSESegment)</code>","text":"<p>Design space exploration tree structure and operations.</p> Source code in <code>brainsmith/core/dse/tree.py</code> <pre><code>def __init__(self, root: DSESegment):\n    self.root = root\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.DSETree.count_leaves","title":"<code>count_leaves() -&gt; int</code>","text":"<p>Count leaf nodes in tree.</p> Source code in <code>brainsmith/core/dse/tree.py</code> <pre><code>def count_leaves(self) -&gt; int:\n    \"\"\"Count leaf nodes in tree.\"\"\"\n    return self._count_leaves(self.root)\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.DSETree.count_nodes","title":"<code>count_nodes() -&gt; int</code>","text":"<p>Count all nodes in tree.</p> Source code in <code>brainsmith/core/dse/tree.py</code> <pre><code>def count_nodes(self) -&gt; int:\n    \"\"\"Count all nodes in tree.\"\"\"\n    return self._count_nodes(self.root)\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.DSETree.get_all_segments","title":"<code>get_all_segments() -&gt; List[DSESegment]</code>","text":"<p>Get all segments in the tree.</p> Source code in <code>brainsmith/core/dse/tree.py</code> <pre><code>def get_all_segments(self) -&gt; List[DSESegment]:\n    \"\"\"Get all segments in the tree.\"\"\"\n    all_segments = []\n\n    def collect_segments(node: DSESegment):\n        all_segments.append(node)\n        for child in node.children.values():\n            collect_segments(child)\n\n    collect_segments(self.root)\n    return all_segments\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.DSETree.get_execution_order","title":"<code>get_execution_order() -&gt; List[DSESegment]</code>","text":"<p>Get breadth-first execution order for the tree.</p> <p>This ensures parent nodes are executed before children, enabling proper result sharing.</p> <p>Returns:</p> Type Description <code>List[DSESegment]</code> <p>List of nodes in execution order</p> Source code in <code>brainsmith/core/dse/tree.py</code> <pre><code>def get_execution_order(self) -&gt; List[DSESegment]:\n    \"\"\"\n    Get breadth-first execution order for the tree.\n\n    This ensures parent nodes are executed before children,\n    enabling proper result sharing.\n\n    Returns:\n        List of nodes in execution order\n    \"\"\"\n    if self.root.segment_id == \"root\" and not self.root.transforms:\n        # Skip empty root node in execution\n        queue = list(self.root.children.values())\n    else:\n        queue = [self.root]\n\n    order = []\n    seen = set()\n\n    while queue:\n        node = queue.pop(0)\n        if id(node) in seen:\n            continue\n\n        seen.add(id(node))\n        order.append(node)\n        queue.extend(node.children.values())\n\n    return order\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.DSETree.get_leaf_segments","title":"<code>get_leaf_segments() -&gt; List[DSESegment]</code>","text":"<p>Get all complete exploration paths (leaf segments).</p> Source code in <code>brainsmith/core/dse/tree.py</code> <pre><code>def get_leaf_segments(self) -&gt; List[DSESegment]:\n    \"\"\"Get all complete exploration paths (leaf segments).\"\"\"\n    leaves = []\n\n    def collect_leaves(node: DSESegment):\n        if node.is_leaf:\n            leaves.append(node)\n        else:\n            for child in node.children.values():\n                collect_leaves(child)\n\n    collect_leaves(self.root)\n    return leaves\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.DSETree.get_statistics","title":"<code>get_statistics() -&gt; Dict[str, Any]</code>","text":"<p>Get statistics about the DSE tree.</p> Source code in <code>brainsmith/core/dse/tree.py</code> <pre><code>def get_statistics(self) -&gt; Dict[str, Any]:\n    \"\"\"Get statistics about the DSE tree.\"\"\"\n    leaf_count = self.count_leaves()\n    node_count = self.count_nodes()\n\n    # Calculate depth\n    max_depth = 0\n\n    def calculate_depth(node: DSESegment, depth: int = 0):\n        nonlocal max_depth\n        max_depth = max(max_depth, depth)  # Count depth from root\n        for child in node.children.values():\n            calculate_depth(child, depth + 1)\n\n    calculate_depth(self.root)\n\n    # Count total transforms\n    total_transforms = 0\n\n    def count_transforms(node: DSESegment):\n        nonlocal total_transforms\n        total_transforms += len(node.transforms)\n        for child in node.children.values():\n            count_transforms(child)\n\n    count_transforms(self.root)\n\n    # Calculate segment efficiency\n    # Without segments, we'd execute all transforms for each path\n    transforms_without_segments = 0\n    for leaf in self.get_leaf_segments():\n        transforms_without_segments += len(leaf.get_all_transforms())\n\n    segment_efficiency = 1 - (total_transforms / transforms_without_segments) if transforms_without_segments &gt; 0 else 0\n\n    return {\n        'total_paths': leaf_count,\n        'total_segments': node_count,\n        'max_depth': max_depth,\n        'total_transforms': total_transforms,\n        'transforms_without_segments': transforms_without_segments,\n        'segment_efficiency': round(segment_efficiency * 100, 1),  # As percentage\n        'avg_transforms_per_segment': round(total_transforms / node_count, 1) if node_count &gt; 0 else 0\n    }\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.DSETree.print_tree","title":"<code>print_tree() -&gt; None</code>","text":"<p>Pretty print the DSE tree.</p> Source code in <code>brainsmith/core/dse/tree.py</code> <pre><code>def print_tree(self) -&gt; None:\n    \"\"\"Pretty print the DSE tree.\"\"\"\n    self._print_node(self.root, \"\", True)\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.SegmentRunner","title":"<code>SegmentRunner(finn_runner: FINNRunner, base_config: Dict[str, Any], kernel_selections: list = None)</code>","text":"<p>Runs DSE segments using FINN.</p> <p>Handles both tree traversal and individual segment execution using FINNRunner for all FINN interactions.</p> <p>Initialize runner.</p> <p>Parameters:</p> Name Type Description Default <code>finn_runner</code> <code>FINNRunner</code> <p>Runner for FINN-specific operations</p> required <code>base_config</code> <code>Dict[str, Any]</code> <p>FINN configuration from blueprint</p> required <code>kernel_selections</code> <code>list</code> <p>Optional list of (kernel, backend) tuples</p> <code>None</code> Source code in <code>brainsmith/core/dse/runner.py</code> <pre><code>def __init__(\n    self,\n    finn_runner: FINNRunner,\n    base_config: Dict[str, Any],\n    kernel_selections: list = None\n) -&gt; None:\n    \"\"\"Initialize runner.\n\n    Args:\n        finn_runner: Runner for FINN-specific operations\n        base_config: FINN configuration from blueprint\n        kernel_selections: Optional list of (kernel, backend) tuples\n    \"\"\"\n    self.finn_runner = finn_runner\n    self.base_config = base_config\n    self.kernel_selections = kernel_selections or []\n\n    # Extract settings from FINN config\n    self.fail_fast = False  # TODO: Add more robust tree exit options\n    output_products = base_config.get(\"output_products\", [\"estimates\"])\n    # Take first output product as primary target\n    self.output_product = output_products[0] if output_products else \"estimates\"\n\n    # Validate required FINN config fields\n    if \"synth_clk_period_ns\" not in base_config:\n        raise ValueError(\"finn_config must specify synth_clk_period_ns\")\n    if \"board\" not in base_config:\n        raise ValueError(\"finn_config must specify board\")\n\n    # Map output products to FINN types\n    self.output_map = {\n        \"estimates\": [\"estimate_reports\"],\n        \"rtl_sim\": [\"estimate_reports\", \"rtlsim_performance\"],\n        \"ip_gen\": [\"estimate_reports\", \"rtlsim_performance\", \"stitched_ip\"],\n        \"bitfile\": [\n            \"estimate_reports\",\n            \"rtlsim_performance\",\n            \"stitched_ip\",\n            \"bitfile\",\n            \"deployment_package\"\n        ]\n    }\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.SegmentRunner.run_segment","title":"<code>run_segment(segment: DSESegment, input_model: Path, base_output_dir: Path) -&gt; SegmentResult</code>","text":"<p>Run a single DSE segment.</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>DSESegment</code> <p>Segment to execute</p> required <code>input_model</code> <code>Path</code> <p>Input ONNX model path</p> required <code>base_output_dir</code> <code>Path</code> <p>Base output directory</p> required <p>Returns:</p> Type Description <code>SegmentResult</code> <p>SegmentResult with execution details</p> Source code in <code>brainsmith/core/dse/runner.py</code> <pre><code>def run_segment(\n    self,\n    segment: DSESegment,\n    input_model: Path,\n    base_output_dir: Path\n) -&gt; SegmentResult:\n    \"\"\"Run a single DSE segment.\n\n    Args:\n        segment: Segment to execute\n        input_model: Input ONNX model path\n        base_output_dir: Base output directory\n\n    Returns:\n        SegmentResult with execution details\n    \"\"\"\n    segment_dir = base_output_dir / segment.segment_id\n    # Use safe filename (segment_id may contain slashes)\n    safe_name = segment.segment_id.replace(\"/\", \"_\")\n    output_model = segment_dir / f\"{safe_name}_output.onnx\"\n\n    if output_model.exists():\n        # Verify it's a valid ONNX file before using cache\n        try:\n            import onnx\n            onnx.load(str(output_model))\n\n            print(f\"\u2713 Using cached: {segment.segment_id}\")\n            return SegmentResult(\n                success=True,\n                segment_id=segment.segment_id,\n                output_model=output_model,\n                output_dir=segment_dir,\n                cached=True\n            )\n        except Exception:\n            # Invalid cache, remove it and rebuild\n            output_model.unlink()\n\n    print(f\"\\n\u2192 Executing: {segment.segment_id}\")\n\n    # Create FINN config\n    finn_config = self._make_finn_config(segment, segment_dir)\n\n    # Prepare directory and model\n    segment_dir.mkdir(parents=True, exist_ok=True)\n    segment_input = segment_dir / \"input.onnx\"\n    self.finn_runner.prepare_model(input_model, segment_input)\n\n    # Execute build\n    start_time = time.time()\n\n    try:\n        # Use runner for clean FINN interaction\n        final_model = self.finn_runner.build(segment_input, finn_config, segment_dir)\n\n        if final_model:\n            # Copy to expected location\n            self.finn_runner.prepare_model(final_model, output_model)\n            print(f\"\u2713 Completed: {segment.segment_id}\")\n            return SegmentResult(\n                success=True,\n                segment_id=segment.segment_id,\n                output_model=output_model,\n                output_dir=segment_dir,\n                execution_time=time.time() - start_time\n            )\n        else:\n            raise RuntimeError(\"Build succeeded but no output model generated\")\n\n    except ExecutionError:\n        # Re-raise our own errors\n        raise\n    except Exception as e:\n        # Wrap external errors with context but preserve stack trace\n        print(f\"\u2717 Failed: {segment.segment_id}\")\n        raise ExecutionError(\n            f\"Segment '{segment.segment_id}' build failed: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.SegmentRunner.run_tree","title":"<code>run_tree(tree: DSETree, initial_model: Path, output_dir: Path) -&gt; TreeExecutionResult</code>","text":"<p>Run all segments in the DSE tree.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>DSETree</code> <p>DSE tree to execute</p> required <code>initial_model</code> <code>Path</code> <p>Path to initial ONNX model</p> required <code>output_dir</code> <code>Path</code> <p>Base output directory</p> required <p>Returns:</p> Type Description <code>TreeExecutionResult</code> <p>TreeExecutionResult with all segment results</p> Source code in <code>brainsmith/core/dse/runner.py</code> <pre><code>def run_tree(\n    self,\n    tree: DSETree,\n    initial_model: Path,\n    output_dir: Path\n) -&gt; TreeExecutionResult:\n    \"\"\"Run all segments in the DSE tree.\n\n    Args:\n        tree: DSE tree to execute\n        initial_model: Path to initial ONNX model\n        output_dir: Base output directory\n\n    Returns:\n        TreeExecutionResult with all segment results\n    \"\"\"\n    output_dir = Path(output_dir)\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    print(f\"Executing tree with fail_fast={self.fail_fast}\")\n    print(f\"Output: {output_dir}\")\n\n    results = {}\n    skipped = set()\n    start_time = time.time()\n\n    # Use a stack for cleaner iteration\n    stack = [(tree.root, initial_model, 0)]\n\n    while stack:\n        segment, input_model, depth = stack.pop()\n        indent = \"  \" * depth\n\n        # Skip if parent failed\n        if segment.segment_id in skipped:\n            print(f\"{indent}\u2298 Skipped: {segment.segment_id}\")\n            results[segment.segment_id] = SegmentResult(\n                success=False,\n                segment_id=segment.segment_id,\n                error=\"Skipped\"\n            )\n            continue\n\n        # Execute segment\n        print(f\"{indent}\u2192 {segment.segment_id}\")\n\n        # Skip empty segments (e.g., root with immediate branches)\n        if not segment.transforms:\n            print(f\"{indent}  (empty segment, passing through)\")\n            # Create a pass-through result\n            results[segment.segment_id] = SegmentResult(\n                success=True,\n                segment_id=segment.segment_id,\n                output_model=input_model,  # Pass input as output\n                output_dir=output_dir / segment.segment_id,\n                execution_time=0\n            )\n            # Add children to stack\n            for child in reversed(list(segment.children.values())):\n                stack.append((child, input_model, depth + 1))\n            continue\n\n        try:\n            result = self.run_segment(segment, input_model, output_dir)\n            results[segment.segment_id] = result\n        except ExecutionError as e:\n            # Handle execution errors properly\n            print(f\"\u2717 Failed: {segment.segment_id}\")\n            print(f\"  Error: {str(e)}\")\n            if self.fail_fast:\n                raise\n\n            # Create failure result with actual exception\n            results[segment.segment_id] = SegmentResult(\n                success=False,\n                segment_id=segment.segment_id,\n                error=str(e),\n                execution_time=0\n            )\n\n            # Mark descendants for skipping\n            self._mark_descendants_skipped(segment, skipped)\n            # Still need to add children to stack so they get marked as skipped\n            for child in reversed(list(segment.children.values())):\n                stack.append((child, None, depth + 1))\n            continue\n        except Exception as e:\n            # Catch any unexpected errors\n            print(f\"\u2717 Failed: {segment.segment_id}\")\n            print(f\"  Unexpected error: {type(e).__name__}: {str(e)}\")\n            import traceback\n            traceback.print_exc()\n\n            # Create failure result\n            results[segment.segment_id] = SegmentResult(\n                success=False,\n                segment_id=segment.segment_id,\n                error=f\"{type(e).__name__}: {str(e)}\",\n                execution_time=0\n            )\n\n            # Mark descendants for skipping\n            self._mark_descendants_skipped(segment, skipped)\n            for child in reversed(list(segment.children.values())):\n                stack.append((child, None, depth + 1))\n            continue\n\n        # Share artifacts at branch points\n        if segment.is_branch_point:\n            share_artifacts_at_branch(result, list(segment.children.values()), output_dir)\n\n        # Add children to stack (reversed for correct order)\n        for child in reversed(list(segment.children.values())):\n            stack.append((child, result.output_model, depth + 1))\n\n    # Create result and print summary\n    total_time = time.time() - start_time\n    result = TreeExecutionResult(results, total_time)\n    self._print_summary(result)\n\n    return result\n</code></pre>"},{"location":"api-reference/core/#design-components","title":"Design Components","text":""},{"location":"api-reference/core/#brainsmith.core.DesignSpace","title":"<code>DesignSpace(model_path: str, steps: List[Union[str, List[Optional[str]]]], kernel_backends: List[Tuple[str, List[Type]]], max_combinations: int = 100000)</code>  <code>dataclass</code>","text":"<p>Design space with resolved plugin objects.</p> <p>This is a clean intermediate representation between blueprint YAML and the execution tree. All plugin names have been resolved to actual classes from the registry.</p>"},{"location":"api-reference/core/#brainsmith.core.DesignSpace.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate steps after initialization.</p> Source code in <code>brainsmith/core/design/space.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Validate steps after initialization.\"\"\"\n    self.validate_steps()\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.DesignSpace.__str__","title":"<code>__str__() -&gt; str</code>","text":"<p>Human-readable representation.</p> Source code in <code>brainsmith/core/design/space.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Human-readable representation.\"\"\"\n    return (\n        f\"DesignSpace(\\n\"\n        f\"  model: {self.model_path}\\n\"\n        f\"  steps: {len(self.steps)}\\n\"\n        f\"  kernels: {len(self.kernel_backends)}\\n\"\n        f\")\"\n    )\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.DesignSpace.get_kernel_summary","title":"<code>get_kernel_summary() -&gt; str</code>","text":"<p>Get human-readable summary of kernels and backends.</p> Source code in <code>brainsmith/core/design/space.py</code> <pre><code>def get_kernel_summary(self) -&gt; str:\n    \"\"\"Get human-readable summary of kernels and backends.\"\"\"\n    lines = []\n    for kernel_name, backend_classes in self.kernel_backends:\n        backend_names = [cls.__name__ for cls in backend_classes]\n        lines.append(f\"  {kernel_name}: {', '.join(backend_names)}\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.DesignSpace.validate_size","title":"<code>validate_size() -&gt; None</code>","text":"<p>Validate that design space doesn't exceed max combinations.</p> Source code in <code>brainsmith/core/design/space.py</code> <pre><code>def validate_size(self) -&gt; None:\n    \"\"\"Validate that design space doesn't exceed max combinations.\"\"\"\n    estimated_size = self._estimate_combinations()\n    if estimated_size &gt; self.max_combinations:\n        raise ValueError(\n            f\"Design space too large: {estimated_size:,} combinations exceeds \"\n            f\"limit of {self.max_combinations:,}\"\n        )\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.DesignSpace.validate_steps","title":"<code>validate_steps() -&gt; None</code>","text":"<p>Validate that all referenced steps exist in the registry.</p> Source code in <code>brainsmith/core/design/space.py</code> <pre><code>def validate_steps(self) -&gt; None:\n    \"\"\"Validate that all referenced steps exist in the registry.\"\"\"\n    invalid_steps = []\n\n    def check_step(step: Optional[str]) -&gt; None:\n        \"\"\"Check if a single step is valid.\"\"\"\n        if step and step not in [\"~\", \"\"] and not has_step(step):\n            invalid_steps.append(step)\n\n    # Check all steps, including those in branch points\n    for step_spec in self.steps:\n        if isinstance(step_spec, list):\n            # Branch point - check each option\n            for option in step_spec:\n                check_step(option)\n        else:\n            # Single step\n            check_step(step_spec)\n\n    if invalid_steps:\n        available_steps = list_all_steps()\n        # Find similar steps for suggestions\n        suggestions = []\n        for invalid in invalid_steps[:3]:  # Limit suggestions\n            similar = [s for s in available_steps if invalid.lower() in s.lower() or s.lower() in invalid.lower()]\n            if similar:\n                suggestions.extend(similar[:2])\n\n        error_msg = f\"Invalid steps found: {', '.join(invalid_steps)}\"\n        if suggestions:\n            error_msg += f\"\\n\\nDid you mean one of these? {', '.join(set(suggestions))}\"\n        error_msg += f\"\\n\\nAvailable steps: {', '.join(available_steps)}\"\n        raise ValueError(error_msg)\n</code></pre>"},{"location":"api-reference/core/#brainsmith.core.parse_blueprint","title":"<code>parse_blueprint(blueprint_path: str, model_path: str) -&gt; Tuple[DesignSpace, ForgeConfig]</code>","text":"<p>Parse blueprint YAML and return DesignSpace and ForgeConfig.</p> <p>Inheritance is resolved bottom-up: 1. Start from the root parent (no extends) 2. Fully resolve its steps (including operations) 3. Pass resolved steps to child for its operations 4. Repeat until we reach the target blueprint</p> Source code in <code>brainsmith/core/design/parser.py</code> <pre><code>def parse_blueprint(blueprint_path: str, model_path: str) -&gt; Tuple[DesignSpace, ForgeConfig]:\n    \"\"\"\n    Parse blueprint YAML and return DesignSpace and ForgeConfig.\n\n    Inheritance is resolved bottom-up:\n    1. Start from the root parent (no extends)\n    2. Fully resolve its steps (including operations)\n    3. Pass resolved steps to child for its operations\n    4. Repeat until we reach the target blueprint\n    \"\"\"\n    # Load raw data to check inheritance chain\n    raw_data = load_yaml(\n        blueprint_path,\n        expand_env_vars=True,\n        support_inheritance=False,\n        context_vars={'BLUEPRINT_DIR': str(Path(blueprint_path).parent.absolute())}\n    )\n\n    parent_steps = None\n\n    # If this blueprint extends another, first parse the parent\n    if 'extends' in raw_data:\n        parent_path = raw_data['extends']\n        # Expand env vars in parent path\n        parent_path = expand_env_vars_with_context(\n            parent_path,\n            {'BSMITH_DIR': os.environ.get('BSMITH_DIR', str(Path(__file__).parent.parent.parent.parent.absolute()))}\n        )\n\n        # Resolve parent path relative to current file\n        if not Path(parent_path).is_absolute():\n            parent_path = str(Path(blueprint_path).parent / parent_path)\n\n        # Recursively parse parent to get its fully resolved steps\n        parent_design_space, _ = parse_blueprint(parent_path, model_path)\n        parent_steps = parent_design_space.steps\n\n    # Now load the full merged data for config extraction\n    blueprint_data = load_yaml(\n        blueprint_path,\n        expand_env_vars=True,\n        support_inheritance=True,\n        context_vars={'BLUEPRINT_DIR': str(Path(blueprint_path).parent.absolute())}\n    )\n\n    forge_config = _extract_config_and_mappings(blueprint_data)\n\n    # Parse steps from THIS blueprint only (not inherited steps)\n    # Use raw_data to get only the steps defined in this file\n    steps_data = raw_data.get('design_space', {}).get('steps', [])\n    steps = _parse_steps(steps_data, parent_steps=parent_steps)\n\n    # Parse kernels (use merged data to inherit kernels)\n    kernel_backends = _parse_kernels(blueprint_data.get('design_space', {}).get('kernels', []))\n\n    # Get max_combinations from environment or use default\n    max_combinations = int(os.environ.get(\"BRAINSMITH_MAX_COMBINATIONS\", \"100000\"))\n\n    design_space = DesignSpace(\n        model_path=model_path,\n        steps=steps,\n        kernel_backends=kernel_backends,\n        max_combinations=max_combinations\n    )\n    design_space.validate_size()\n    return design_space, forge_config\n</code></pre>"},{"location":"api-reference/core/#configuration","title":"Configuration","text":""},{"location":"api-reference/core/#brainsmith.core.ForgeConfig","title":"<code>ForgeConfig(clock_ns: float, output: Literal['estimates', 'rtl', 'bitfile'] = 'estimates', board: Optional[str] = None, verify: bool = False, verify_data: Optional[Path] = None, parallel_builds: int = 4, debug: bool = False, save_intermediate_models: bool = False, start_step: Optional[str] = None, stop_step: Optional[str] = None, finn_overrides: Dict[str, Any] = dict())</code>  <code>dataclass</code>","text":"<p>Configuration that actually works.</p>"},{"location":"api-reference/plugins/","title":"Plugin System API Reference","text":"<p>The plugin system is the core of Brainsmith's extensibility.</p>"},{"location":"api-reference/plugins/#registry","title":"Registry","text":""},{"location":"api-reference/plugins/#brainsmith.core.plugins.registry.Registry","title":"<code>Registry()</code>","text":"Source code in <code>brainsmith/core/plugins/registry.py</code> <pre><code>def __init__(self):\n    self._plugins: Dict[str, Dict[str, Tuple[Type, Dict[str, Any]]]] = {\n        'transform': {}, 'kernel': {}, 'backend': {}, 'step': {}\n    }\n</code></pre>"},{"location":"api-reference/plugins/#brainsmith.core.plugins.registry.Registry.register","title":"<code>register(plugin_type: str, name: str, cls: Type, framework: str = 'brainsmith', **metadata) -&gt; None</code>","text":"<p>Register a plugin with optional framework namespace.</p> Source code in <code>brainsmith/core/plugins/registry.py</code> <pre><code>def register(self, plugin_type: str, name: str, cls: Type, \n             framework: str = 'brainsmith', **metadata) -&gt; None:\n    \"\"\"Register a plugin with optional framework namespace.\"\"\"\n    key = f\"{framework}:{name}\" if framework != 'brainsmith' else name\n    self._plugins[plugin_type][key] = (cls, {**metadata, 'framework': framework})\n</code></pre>"},{"location":"api-reference/plugins/#brainsmith.core.plugins.registry.Registry.get","title":"<code>get(plugin_type: str, name: str) -&gt; Type</code>","text":"<p>Get plugin by name (with or without framework prefix).</p> Source code in <code>brainsmith/core/plugins/registry.py</code> <pre><code>def get(self, plugin_type: str, name: str) -&gt; Type:\n    \"\"\"Get plugin by name (with or without framework prefix).\n    \"\"\"\n    self._load_plugins()\n\n    # Direct lookup first\n    plugins = self._plugins[plugin_type]\n    if name in plugins:\n        return plugins[name][0]\n\n    # If no colon, try with framework prefixes\n    if ':' not in name:\n        # Try common prefixes\n        for prefix in ['brainsmith:', 'finn:', 'qonnx:']:\n            full_name = f'{prefix}{name}'\n            if full_name in plugins:\n                return plugins[full_name][0]\n\n    # Plugin not found - fail fast\n    available = list(self._plugins[plugin_type].keys())\n    raise KeyError(\n        f\"Plugin {plugin_type}:{name} not found. \"\n        f\"Available ({len(available)}): {available[:10] if available else 'none'}\"\n    )\n</code></pre>"},{"location":"api-reference/plugins/#brainsmith.core.plugins.registry.Registry.find","title":"<code>find(plugin_type: str, **criteria) -&gt; List[Type]</code>","text":"<p>Find plugins matching criteria.</p> Source code in <code>brainsmith/core/plugins/registry.py</code> <pre><code>def find(self, plugin_type: str, **criteria) -&gt; List[Type]:\n    \"\"\"Find plugins matching criteria.\"\"\"\n    self._load_plugins()\n    results = []\n    for name, (cls, metadata) in self._plugins[plugin_type].items():\n        if all(metadata.get(k) == v for k, v in criteria.items()):\n            results.append(cls)\n    return results\n</code></pre>"},{"location":"api-reference/plugins/#brainsmith.core.plugins.registry.Registry.all","title":"<code>all(plugin_type: str) -&gt; Dict[str, Type]</code>","text":"<p>Get all plugins of a type.</p> Source code in <code>brainsmith/core/plugins/registry.py</code> <pre><code>def all(self, plugin_type: str) -&gt; Dict[str, Type]:\n    \"\"\"Get all plugins of a type.\"\"\"\n    self._load_plugins()\n    return {name: cls for name, (cls, _) in self._plugins[plugin_type].items()}\n</code></pre>"},{"location":"api-reference/plugins/#brainsmith.core.plugins.registry.Registry.reset","title":"<code>reset() -&gt; None</code>","text":"<p>Reset registry and reload all plugins.</p> <p>This is primarily for testing to ensure a clean state.</p> Source code in <code>brainsmith/core/plugins/registry.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset registry and reload all plugins.\n\n    This is primarily for testing to ensure a clean state.\n    \"\"\"\n    # Clear all plugins\n    self._plugins = {\n        'transform': {}, 'kernel': {}, 'backend': {}, 'step': {}\n    }\n\n    # Reset the discovery flag to force reloading\n    if hasattr(self, '_discovered'):\n        delattr(self, '_discovered')\n\n    # Reset framework adapter initialization state\n    try:\n        from . import framework_adapters\n        framework_adapters._initialized = False\n    except ImportError:\n        pass\n\n    self._load_plugins()\n\n    logger.debug(\"Registry reset and plugins reloaded\")\n</code></pre>"},{"location":"api-reference/plugins/#registration-decorators","title":"Registration Decorators","text":""},{"location":"api-reference/plugins/#brainsmith.core.plugins.registry.transform","title":"<code>transform = lambda **kw: plugin('transform', **kw)</code>  <code>module-attribute</code>","text":""},{"location":"api-reference/plugins/#brainsmith.core.plugins.registry.kernel","title":"<code>kernel = lambda **kw: plugin('kernel', **kw)</code>  <code>module-attribute</code>","text":""},{"location":"api-reference/plugins/#brainsmith.core.plugins.registry.backend","title":"<code>backend = lambda **kw: plugin('backend', **kw)</code>  <code>module-attribute</code>","text":""},{"location":"api-reference/plugins/#brainsmith.core.plugins.registry.step","title":"<code>step = lambda **kw: plugin('step', **kw)</code>  <code>module-attribute</code>","text":""},{"location":"api-reference/plugins/#access-functions","title":"Access Functions","text":""},{"location":"api-reference/plugins/#brainsmith.core.plugins.registry.get_transform","title":"<code>get_transform(name: str) -&gt; Type</code>","text":"Source code in <code>brainsmith/core/plugins/registry.py</code> <pre><code>def get_transform(name: str) -&gt; Type:\n    return _registry.get('transform', name)\n</code></pre>"},{"location":"api-reference/plugins/#brainsmith.core.plugins.registry.get_kernel","title":"<code>get_kernel(name: str) -&gt; Type</code>","text":"Source code in <code>brainsmith/core/plugins/registry.py</code> <pre><code>def get_kernel(name: str) -&gt; Type:\n    return _registry.get('kernel', name)\n</code></pre>"},{"location":"api-reference/plugins/#brainsmith.core.plugins.registry.get_backend","title":"<code>get_backend(name: str) -&gt; Type</code>","text":"Source code in <code>brainsmith/core/plugins/registry.py</code> <pre><code>def get_backend(name: str) -&gt; Type:\n    return _registry.get('backend', name)\n</code></pre>"},{"location":"api-reference/plugins/#brainsmith.core.plugins.registry.get_step","title":"<code>get_step(name: str) -&gt; Type</code>","text":"Source code in <code>brainsmith/core/plugins/registry.py</code> <pre><code>def get_step(name: str) -&gt; Type:\n    return _registry.get('step', name)\n</code></pre>"},{"location":"api-reference/plugins/#query-functions","title":"Query Functions","text":""},{"location":"api-reference/plugins/#brainsmith.core.plugins.registry.list_transforms","title":"<code>list_transforms() -&gt; List[str]</code>","text":"<p>List all transform names.</p> Source code in <code>brainsmith/core/plugins/registry.py</code> <pre><code>def list_transforms() -&gt; List[str]:\n    \"\"\"List all transform names.\"\"\"\n    _registry._load_plugins()\n    return list(_registry._plugins['transform'].keys())\n</code></pre>"},{"location":"api-reference/plugins/#brainsmith.core.plugins.registry.list_kernels","title":"<code>list_kernels() -&gt; List[str]</code>","text":"<p>List all kernel names.</p> Source code in <code>brainsmith/core/plugins/registry.py</code> <pre><code>def list_kernels() -&gt; List[str]:\n    \"\"\"List all kernel names.\"\"\"\n    _registry._load_plugins()\n    return list(_registry._plugins['kernel'].keys())\n</code></pre>"},{"location":"api-reference/plugins/#brainsmith.core.plugins.registry.has_transform","title":"<code>has_transform(name: str) -&gt; bool</code>","text":"<p>Check if transform exists.</p> Source code in <code>brainsmith/core/plugins/registry.py</code> <pre><code>def has_transform(name: str) -&gt; bool:\n    \"\"\"Check if transform exists.\"\"\"\n    try:\n        _registry.get('transform', name)\n        return True\n    except KeyError:\n        return False\n</code></pre>"},{"location":"api-reference/plugins/#brainsmith.core.plugins.registry.has_kernel","title":"<code>has_kernel(name: str) -&gt; bool</code>","text":"<p>Check if kernel exists.</p> Source code in <code>brainsmith/core/plugins/registry.py</code> <pre><code>def has_kernel(name: str) -&gt; bool:\n    \"\"\"Check if kernel exists.\"\"\"\n    try:\n        _registry.get('kernel', name)\n        return True\n    except KeyError:\n        return False\n</code></pre>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>Brainsmith's architecture is built around three core concepts: Blueprints, Plugins, and Segment-based DSE.</p>"},{"location":"architecture/overview/#high-level-architecture","title":"High-Level Architecture","text":"<pre><code>graph TB\n    A[Blueprint YAML] --&gt; B[Design Space Parser]\n    B --&gt; C[DSE Tree Builder]\n    C --&gt; D[Exploration Tree]\n    D --&gt; E[Segment Runner]\n    E --&gt; F{Plugin Registry}\n    F --&gt; G[Transforms]\n    F --&gt; H[Kernels]\n    F --&gt; I[Steps]\n    E --&gt; J[Build Artifacts]\n    J --&gt; K[RTL Output]</code></pre>"},{"location":"architecture/overview/#core-components","title":"Core Components","text":""},{"location":"architecture/overview/#1-blueprint-system","title":"1. Blueprint System","text":"<p>Blueprints define design spaces in YAML:</p> <pre><code>name: \"My Accelerator\"\ndesign_space:\n  kernels:\n    - MatMul\n    - Conv2d\n  steps:\n    - cleanup\n    - qonnx_to_finn\n    - step_create_dataflow_partition\n</code></pre> <p>Key Features:</p> <ul> <li>Inheritance support (<code>extends: base.yaml</code>)</li> <li>Dynamic step operations (insert, replace, remove)</li> <li>Parameter sweeps for exploration</li> </ul> <p>Location: <code>brainsmith/core/design/</code></p>"},{"location":"architecture/overview/#2-plugin-registry","title":"2. Plugin Registry","text":"<p>A singleton registry manages all extensible components:</p> <pre><code>from brainsmith.core.plugins import transform, kernel, step\n\n@transform(name=\"MyTransform\")\nclass MyTransform:\n    def apply(self, model):\n        # Transform logic\n        pass\n\n@kernel(name=\"MyKernel\")\nclass MyKernel:\n    # Kernel implementation\n    pass\n</code></pre> <p>Plugin Types:</p> <ul> <li>Transforms - Graph transformations</li> <li>Kernels - Hardware operator implementations</li> <li>Backends - RTL/HLS implementations per kernel</li> <li>Steps - Build pipeline operations</li> </ul> <p>Location: <code>brainsmith/core/plugins/registry.py</code></p>"},{"location":"architecture/overview/#3-segment-based-dse","title":"3. Segment-Based DSE","text":"<p>The exploration tree is divided into segments for efficient computation reuse:</p> <pre><code>graph TD\n    A[Root: Model Input] --&gt; B[Segment 1: Preprocessing]\n    B --&gt; C[Segment 2: Kernel Selection]\n    C --&gt; D[Branch A: RTL Backend]\n    C --&gt; E[Branch B: HLS Backend]\n    D --&gt; F[Segment 3a: RTL Codegen]\n    E --&gt; G[Segment 3b: HLS Codegen]</code></pre> <p>Benefits:</p> <ul> <li>Only changed segments re-execute</li> <li>Shared artifacts cached across branches</li> <li>Parallelizable execution (planned)</li> </ul> <p>Location: <code>brainsmith/core/dse/</code></p>"},{"location":"architecture/overview/#compilation-pipeline","title":"Compilation Pipeline","text":"<p>The standard dataflow compilation follows this pipeline:</p> <pre><code>sequenceDiagram\n    participant U as User\n    participant B as Blueprint Parser\n    participant D as DSE Engine\n    participant P as Plugin Registry\n    participant F as FINN\n\n    U-&gt;&gt;B: Load blueprint\n    B-&gt;&gt;D: Build exploration tree\n    D-&gt;&gt;P: Get transforms/kernels\n    P-&gt;&gt;D: Return plugin instances\n    D-&gt;&gt;F: Execute transforms\n    F-&gt;&gt;D: Return transformed model\n    D-&gt;&gt;U: Generate RTL + reports</code></pre>"},{"location":"architecture/overview/#pipeline-stages","title":"Pipeline Stages","text":"<ol> <li>ONNX \u2192 QONNX - Add quantization metadata</li> <li>QONNX \u2192 FINN - Create dataflow partition</li> <li>Kernel Inference - Replace ops with hardware kernels</li> <li>Specialization - Configure kernel parameters</li> <li>Folding - Apply parallelization strategy</li> <li>Bit Width Minimization - Optimize data types</li> <li>Hardware Codegen - Generate RTL/HLS</li> <li>IP Generation - Create Vivado IP blocks</li> <li>FIFO Sizing - Determine buffer depths</li> <li>Stitched IP - Connect kernels with AXI stream</li> <li>RTL Simulation - Verify correctness</li> </ol>"},{"location":"architecture/overview/#configuration-system","title":"Configuration System","text":"<p>Pydantic-based configuration with layered overrides:</p> <pre><code>graph LR\n    A[Built-in Defaults] --&gt; B[Project Config]\n    B --&gt; C[User Config]\n    C --&gt; D[CLI Args]\n    D --&gt; E[Effective Config]</code></pre> <p>Priority Order:</p> <ol> <li>CLI arguments / environment vars (highest)</li> <li>Explicit <code>--config</code> file</li> <li><code>~/.brainsmith/config.yaml</code> (user)</li> <li><code>.brainsmith/config.yaml</code> (project)</li> <li>Built-in defaults (lowest)</li> </ol> <p>Location: <code>brainsmith/config/</code></p>"},{"location":"architecture/overview/#two-cli-design","title":"Two-CLI Design","text":""},{"location":"architecture/overview/#brainsmith-cli","title":"<code>brainsmith</code> CLI","text":"<p>Application-level commands:</p> <ul> <li><code>config init/show/export</code> - Configuration management</li> <li><code>setup all</code> - Dependency installation</li> <li><code>smith ...</code> - Proxy to smith CLI</li> </ul>"},{"location":"architecture/overview/#smith-cli","title":"<code>smith</code> CLI","text":"<p>Operational commands:</p> <ul> <li><code>dse model.onnx blueprint.yaml</code> - Run DSE</li> <li><code>kernel file.sv</code> - Generate kernel from RTL</li> </ul> <p>Location: <code>brainsmith/interface/cli.py</code></p>"},{"location":"architecture/overview/#key-patterns","title":"Key Patterns","text":""},{"location":"architecture/overview/#decorator-based-registration","title":"Decorator-Based Registration","text":"<pre><code>@transform(name=\"CustomTransform\", framework=\"brainsmith\")\nclass CustomTransform(Transformation):\n    pass\n</code></pre>"},{"location":"architecture/overview/#framework-integration","title":"Framework Integration","text":"<p>External transforms from FINN/QONNX are wrapped:</p> <pre><code># Automatically wrapped\nget_transform(\"finn:Streamline\")  # FINN transform\nget_transform(\"qonnx:InferShapes\")  # QONNX transform\n</code></pre>"},{"location":"architecture/overview/#lazy-plugin-loading","title":"Lazy Plugin Loading","text":"<p>Plugins are discovered on first access:</p> <pre><code># First call triggers discovery\ntransform_cls = get_transform(\"MyTransform\")\n</code></pre>"},{"location":"architecture/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Plugin System - Deep dive into plugins</li> </ul>"},{"location":"architecture/plugin-system/","title":"Plugin System","text":"<p>The plugin system is Brainsmith's core extensibility mechanism, enabling custom kernels, transforms, and build steps.</p>"},{"location":"architecture/plugin-system/#overview","title":"Overview","text":"<p>The plugin registry is a singleton that manages all extensible components with decorator-based registration:</p> <pre><code>from brainsmith.core.plugins import transform, kernel, backend, step\n\n@transform(name=\"MyTransform\")\nclass MyTransform:\n    def apply(self, model):\n        # Your transformation logic\n        return model\n\n@kernel(name=\"MyKernel\")\nclass MyKernel:\n    pass\n\n@backend(kernel=\"MyKernel\", name=\"rtl\", default=True)\nclass MyKernelRTL:\n    pass\n\n@step(name=\"my_step\")\ndef my_custom_step(model, cfg):\n    # Custom build step\n    return model\n</code></pre>"},{"location":"architecture/plugin-system/#plugin-types","title":"Plugin Types","text":""},{"location":"architecture/plugin-system/#transforms","title":"Transforms","text":"<p>Graph transformations that modify the ONNX/QONNX model:</p> <pre><code>@transform(name=\"RemoveIdentity\", framework=\"brainsmith\")\nclass RemoveIdentity(Transformation):\n    def apply(self, model):\n        # Remove identity nodes\n        for node in model.graph.node:\n            if node.op_type == \"Identity\":\n                # Remove node logic\n                pass\n        return model\n</code></pre> <p>Access: <pre><code>from brainsmith.core.plugins import get_transform\n\ntransform_cls = get_transform(\"RemoveIdentity\")\ntransform = transform_cls()\nmodel = transform.apply(model)\n</code></pre></p>"},{"location":"architecture/plugin-system/#kernels","title":"Kernels","text":"<p>Hardware operator implementations:</p> <pre><code>@kernel(name=\"MatMul\")\nclass MatMulKernel:\n    \"\"\"Matrix multiplication kernel.\"\"\"\n\n    def __init__(self, onnx_node):\n        self.onnx_node = onnx_node\n\n    def make_weight_file(self):\n        # Generate weight files\n        pass\n</code></pre> <p>Access: <pre><code>from brainsmith.core.plugins import get_kernel\n\nkernel_cls = get_kernel(\"MatMul\")\nkernel = kernel_cls(onnx_node)\n</code></pre></p>"},{"location":"architecture/plugin-system/#backends","title":"Backends","text":"<p>RTL or HLS implementations per kernel:</p> <pre><code>@backend(kernel=\"MatMul\", name=\"rtl\", default=True)\nclass MatMulRTL:\n    \"\"\"RTL backend for MatMul.\"\"\"\n\n    def generate_hdl(self):\n        # Generate RTL code\n        pass\n\n@backend(kernel=\"MatMul\", name=\"hls\")\nclass MatMulHLS:\n    \"\"\"HLS backend for MatMul.\"\"\"\n\n    def generate_hls(self):\n        # Generate HLS code\n        pass\n</code></pre> <p>Access: <pre><code>from brainsmith.core.plugins import get_backend\n\nbackend_cls = get_backend(\"MatMul\", \"rtl\")\nbackend = backend_cls()\n</code></pre></p>"},{"location":"architecture/plugin-system/#steps","title":"Steps","text":"<p>Build pipeline operations:</p> <pre><code>@step(name=\"my_optimization\")\ndef my_optimization_step(model, cfg):\n    \"\"\"Custom optimization step.\"\"\"\n    # Apply optimizations\n    return model\n</code></pre> <p>Access: <pre><code>from brainsmith.core.plugins import get_step\n\nstep_fn = get_step(\"my_optimization\")\nmodel = step_fn(model, config)\n</code></pre></p>"},{"location":"architecture/plugin-system/#framework-integration","title":"Framework Integration","text":"<p>Brainsmith integrates FINN and QONNX transforms automatically:</p> <pre><code># FINN transforms\nget_transform(\"finn:Streamline\")\nget_transform(\"finn:InferShapes\")\n\n# QONNX transforms\nget_transform(\"qonnx:ConvertSubToAdd\")\nget_transform(\"qonnx:InferDataTypes\")\n</code></pre> <p>These are automatically discovered and wrapped with the <code>framework</code> prefix.</p>"},{"location":"architecture/plugin-system/#registration-api","title":"Registration API","text":""},{"location":"architecture/plugin-system/#manual-registration","title":"Manual Registration","text":"<pre><code>from brainsmith.core.plugins.registry import _registry\n\n_registry.register(\n    plugin_type='transform',\n    name='CustomTransform',\n    cls=CustomTransform,\n    framework='brainsmith',\n    metadata={'version': '1.0'}\n)\n</code></pre>"},{"location":"architecture/plugin-system/#query-functions","title":"Query Functions","text":"<pre><code>from brainsmith.core.plugins import (\n    list_transforms,\n    list_kernels,\n    has_transform,\n    has_kernel\n)\n\n# List all transforms\ntransforms = list_transforms()\n\n# List all kernels\nkernels = list_kernels()\n\n# Check if transform exists\nif has_transform(\"MyTransform\"):\n    ...\n\n# Check if kernel exists\nif has_kernel(\"MatMul\"):\n    ...\n</code></pre>"},{"location":"architecture/plugin-system/#discovery-and-loading","title":"Discovery and Loading","text":"<p>Plugins are lazy-loaded on first access:</p> <ol> <li>Auto-discovery: Registry imports <code>brainsmith.{transforms,kernels,steps,operators}</code></li> <li>Framework adapters: FINN/QONNX plugins loaded on first framework prefix access</li> <li>Decorator registration: <code>@transform</code>, <code>@kernel</code>, etc. register during module import</li> </ol> <pre><code># First access triggers discovery\ntransform_cls = get_transform(\"MyTransform\")  # Auto-discovers all transforms\n\n# Subsequent access uses cache\ntransform_cls2 = get_transform(\"MyTransform\")  # From cache\n</code></pre>"},{"location":"architecture/plugin-system/#blueprint-integration","title":"Blueprint Integration","text":"<p>Reference plugins declaratively in blueprints:</p> <pre><code>design_space:\n  kernels:\n    - name: MatMul\n      backends:\n        - rtl  # References MatMulRTL backend\n        - hls  # References MatMulHLS backend\n\n  steps:\n    - cleanup  # References cleanup step\n    - qonnx_to_finn\n    - my_optimization  # References custom step\n    - finn:Streamline  # References FINN transform\n</code></pre>"},{"location":"architecture/plugin-system/#best-practices","title":"Best Practices","text":""},{"location":"architecture/plugin-system/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Transforms: PascalCase, descriptive (e.g., <code>RemoveUnusedNodes</code>)</li> <li>Kernels: PascalCase, operator name (e.g., <code>Conv2d</code>, <code>MatMul</code>)</li> <li>Backends: <code>{Kernel}{Backend}</code> (e.g., <code>MatMulRTL</code>, <code>Conv2dHLS</code>)</li> <li>Steps: snake_case, action-oriented (e.g., <code>step_create_partition</code>)</li> </ul>"},{"location":"architecture/plugin-system/#metadata","title":"Metadata","text":"<p>Add metadata for discoverability:</p> <pre><code>@transform(\n    name=\"MyTransform\",\n    framework=\"brainsmith\",\n    version=\"1.0\",\n    description=\"Optimizes graph structure\"\n)\nclass MyTransform:\n    pass\n</code></pre>"},{"location":"architecture/plugin-system/#testing","title":"Testing","text":"<p>Test plugins in isolation:</p> <pre><code>def test_my_transform():\n    from brainsmith.core.plugins import get_transform\n\n    transform_cls = get_transform(\"MyTransform\")\n    transform = transform_cls()\n\n    # Test transformation\n    result = transform.apply(model)\n    assert result is not None\n</code></pre>"},{"location":"architecture/plugin-system/#api-reference","title":"API Reference","text":"<p>For detailed API documentation, see:</p> <ul> <li>Plugin Registry API</li> <li>Core API</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>Brainsmith uses a Pydantic-based configuration system with multiple sources for maximum flexibility.</p>"},{"location":"getting-started/configuration/#configuration-sources","title":"Configuration Sources","text":"<p>Configurations are loaded in priority order (highest to lowest):</p> <ol> <li>CLI arguments / environment variables - Override all other sources</li> <li>Explicit config file - Via <code>--config</code> or <code>BRAINSMITH_CONFIG</code></li> <li>User config - <code>~/.brainsmith/config.yaml</code></li> <li>Project config - <code>.brainsmith/config.yaml</code> (in repo)</li> <li>Built-in defaults - Hardcoded fallbacks</li> </ol>"},{"location":"getting-started/configuration/#configuration-file-format","title":"Configuration File Format","text":"<pre><code># Example: ~/.brainsmith/config.yaml\n\n# Xilinx tool paths\nxilinx_path: /opt/Xilinx/Vivado/2024.2\nxilinx_version: 2024.2\n\n# Build directory\nbuild_dir: /tmp/finn_dev_${USER}\n\n# Optional: Override specific settings\nlog_level: INFO\nparallel_builds: 4\n</code></pre>"},{"location":"getting-started/configuration/#key-configuration-options","title":"Key Configuration Options","text":""},{"location":"getting-started/configuration/#xilinx-tools","title":"Xilinx Tools","text":"<pre><code>xilinx_path: /opt/Xilinx/Vivado/2024.2\nxilinx_version: 2024.2\n</code></pre> <p>Required for synthesis and implementation. The path should point to your Vivado installation directory.</p>"},{"location":"getting-started/configuration/#build-directory","title":"Build Directory","text":"<pre><code>build_dir: /tmp/finn_dev_${USER}\n</code></pre> <p>Where temporary build artifacts are stored. Can use environment variables like <code>${USER}</code>.</p>"},{"location":"getting-started/configuration/#logging","title":"Logging","text":"<pre><code>log_level: DEBUG  # DEBUG, INFO, WARNING, ERROR\n</code></pre> <p>Controls verbosity of logging output.</p>"},{"location":"getting-started/configuration/#cli-configuration-commands","title":"CLI Configuration Commands","text":""},{"location":"getting-started/configuration/#initialize-config","title":"Initialize Config","text":"<pre><code># Create default config file\nbrainsmith config init\n</code></pre> <p>Creates <code>~/.brainsmith/config.yaml</code> with default values.</p>"},{"location":"getting-started/configuration/#view-current-config","title":"View Current Config","text":"<pre><code># Show effective configuration (all sources merged)\nbrainsmith config show\n</code></pre>"},{"location":"getting-started/configuration/#export-environment","title":"Export Environment","text":"<pre><code># Export Xilinx environment variables\neval $(brainsmith config export)\n</code></pre> <p>This sets up <code>XILINX_ROOT</code>, <code>XILINX_VERSION</code>, and other environment variables needed by FINN and Vivado.</p>"},{"location":"getting-started/configuration/#cli-overrides","title":"CLI Overrides","text":"<p>Override configuration via command-line:</p> <pre><code># Override build directory\nsmith dse model.onnx blueprint.yaml --build-dir /custom/path\n\n# Use specific config file\nsmith --config /path/to/config.yaml dse model.onnx blueprint.yaml\n\n# Enable debug mode\nsmith --debug dse model.onnx blueprint.yaml\n</code></pre>"},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":"<p>You can also use environment variables:</p> <pre><code>export BRAINSMITH_CONFIG=/path/to/config.yaml\nexport BRAINSMITH_BUILD_DIR=/custom/build/dir\n</code></pre>"},{"location":"getting-started/configuration/#project-specific-configuration","title":"Project-Specific Configuration","text":"<p>For project-specific settings, create <code>.brainsmith/config.yaml</code> in your project root:</p> <pre><code># .brainsmith/config.yaml (in git repo)\nbuild_dir: ./build\nlog_level: DEBUG\n</code></pre> <p>This allows different projects to have different defaults while keeping user settings separate.</p>"},{"location":"getting-started/configuration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/configuration/#config-not-found","title":"Config not found","text":"<pre><code># Verify config file exists\nls -la ~/.brainsmith/config.yaml\n\n# Re-initialize if needed\nbrainsmith config init\n</code></pre>"},{"location":"getting-started/configuration/#wrong-xilinx-path","title":"Wrong Xilinx path","text":"<pre><code># Check current setting\nbrainsmith config show | grep xilinx\n\n# Update in config file\nnano ~/.brainsmith/config.yaml\n</code></pre>"},{"location":"getting-started/configuration/#environment-not-set","title":"Environment not set","text":"<pre><code># Make sure to run export command\neval $(brainsmith config export)\n\n# Verify environment\necho $XILINX_ROOT\n</code></pre>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>CLI Reference - Full command documentation</li> <li>Architecture - How configuration flows through the system</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide will help you set up Brainsmith for development.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ubuntu 22.04+</li> <li>Python 3.10+</li> <li>Vivado Design Suite 2024.2</li> <li>Poetry</li> </ul>"},{"location":"getting-started/installation/#poetry-environment-setup","title":"Poetry Environment Setup","text":""},{"location":"getting-started/installation/#automated-setup","title":"Automated Setup","text":"<pre><code># Run automated setup script\n./setup-venv.sh\n\n# Activate virtual environment\nsource .venv/bin/activate\n</code></pre>"},{"location":"getting-started/installation/#manual-setup","title":"Manual Setup","text":"<p>If you prefer manual setup:</p> <pre><code># Install Poetry (if not already installed)\ncurl -sSL https://install.python-poetry.org | python3 -\n\n# Install dependencies\npoetry install\n\n# Activate virtual environment\npoetry shell\n</code></pre>"},{"location":"getting-started/installation/#configuration","title":"Configuration","text":""},{"location":"getting-started/installation/#initialize-configuration","title":"Initialize Configuration","text":"<pre><code># Create config file\nbrainsmith config init\n</code></pre> <p>This creates <code>~/.brainsmith/config.yaml</code>.</p>"},{"location":"getting-started/installation/#edit-configuration","title":"Edit Configuration","text":"<p>Edit <code>~/.brainsmith/config.yaml</code> to set your Xilinx paths:</p> <pre><code>xilinx_path: /opt/Xilinx/Vivado/2024.2\nxilinx_version: 2024.2\nbuild_dir: /tmp/finn_dev_${USER}\n</code></pre>"},{"location":"getting-started/installation/#verify-configuration","title":"Verify Configuration","text":"<pre><code># View current configuration\nbrainsmith config show\n\n# Export environment variables\neval $(brainsmith config export)\n</code></pre>"},{"location":"getting-started/installation/#validate-installation","title":"Validate Installation","text":"<p>Run the quick validation test:</p> <pre><code>./examples/bert/quicktest.sh\n</code></pre> <p>This runs a minimal BERT example (single layer) to verify everything works.</p>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Run your first DSE</li> <li>Configuration Guide - Learn about configuration options</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Get started with Brainsmith in 5 minutes.</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<p>Make sure you've completed the installation.</p>"},{"location":"getting-started/quickstart/#run-your-first-dse","title":"Run Your First DSE","text":""},{"location":"getting-started/quickstart/#1-prepare-your-model","title":"1. Prepare Your Model","text":"<p>For this quickstart, we'll use the included BERT example:</p> <pre><code>cd examples/bert\n</code></pre>"},{"location":"getting-started/quickstart/#2-run-the-quick-test","title":"2. Run the Quick Test","text":"<pre><code>./quicktest.sh\n</code></pre> <p>This will:</p> <ol> <li>Generate a folding configuration for minimal resources</li> <li>Build a single-layer BERT accelerator</li> <li>Run RTL simulation to verify correctness</li> </ol> <p>Build Time</p> <p>The quicktest takes approximately 30-60 minutes, depending on your system.</p>"},{"location":"getting-started/quickstart/#3-explore-results","title":"3. Explore Results","text":"<p>Results are saved in <code>examples/bert/quicktest/</code>:</p> <pre><code>quicktest/\n\u251c\u2500\u2500 model.onnx              # Quantized ONNX model\n\u251c\u2500\u2500 final_output/           # Generated RTL and reports\n\u2502   \u251c\u2500\u2500 stitched_ip/       # Synthesizable RTL\n\u2502   \u2514\u2500\u2500 report/            # Performance estimates\n\u2514\u2500\u2500 build_dataflow.log     # Build log\n</code></pre>"},{"location":"getting-started/quickstart/#understanding-the-output","title":"Understanding the Output","text":""},{"location":"getting-started/quickstart/#performance-report","title":"Performance Report","text":"<p>Check <code>final_output/report/estimate_reports.json</code>:</p> <pre><code>{\n  \"throughput\": \"1234.5 fps\",\n  \"latency\": \"0.81 ms\",\n  \"resources\": {\n    \"LUT\": 12345,\n    \"FF\": 23456,\n    \"BRAM\": 34,\n    \"DSP\": 56\n  }\n}\n</code></pre>"},{"location":"getting-started/quickstart/#rtl-output","title":"RTL Output","text":"<p>The generated RTL is in <code>final_output/stitched_ip/</code>:</p> <ul> <li><code>finn_design_wrapper.v</code> - Top-level module</li> <li><code>*.v</code> - Individual kernel implementations</li> </ul>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":""},{"location":"getting-started/quickstart/#customize-the-design","title":"Customize the Design","text":"<p>Edit the blueprint to explore different configurations:</p> <pre><code># bert_quicktest.yaml\ndesign_space:\n  kernels:\n    - name: MatMul\n      backends:\n        - matmul_rtl  # Try different backends\n  steps:\n    - step_target_fps_parallelization:\n        target_fps: 100  # Adjust target performance\n</code></pre>"},{"location":"getting-started/quickstart/#run-full-dse","title":"Run Full DSE","text":"<pre><code>smith model.onnx blueprint.yaml --output-dir ./results\n</code></pre>"},{"location":"getting-started/quickstart/#learn-more","title":"Learn More","text":"<ul> <li>Architecture Overview - Understand how Brainsmith works</li> <li>CLI Reference - Explore CLI commands</li> </ul>"}]}