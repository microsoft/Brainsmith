"""
Test suite for Week 4 Enhanced Generators.

Tests the enhanced HW Custom Op and RTL Backend generators that use
the new architecture while maintaining compatibility.
"""

import pytest
import time
from unittest.mock import Mock, patch, MagicMock
from pathlib import Path

from brainsmith.tools.hw_kernel_gen.enhanced_config import PipelineConfig, GeneratorType, DataflowMode
from brainsmith.tools.hw_kernel_gen.enhanced_data_structures import (
    RTLModule, RTLInterface, RTLSignal
)
from brainsmith.tools.hw_kernel_gen.enhanced_generator_base import GenerationResult, GeneratedArtifact
from brainsmith.tools.hw_kernel_gen.generators.enhanced_hw_custom_op_generator import (
    EnhancedHWCustomOpGenerator, create_enhanced_hw_custom_op_generator, generate_enhanced_hwcustomop
)
from brainsmith.tools.hw_kernel_gen.generators.enhanced_rtl_backend_generator import (
    EnhancedRTLBackendGenerator, create_enhanced_rtl_backend_generator, generate_enhanced_rtlbackend
)
from brainsmith.tools.hw_kernel_gen.orchestration.generator_factory import GeneratorCapability


class TestEnhancedHWCustomOpGenerator:
    """Test enhanced HW Custom Op generator."""
    
    def setup_method(self):
        """Set up test fixtures."""
        self.config = PipelineConfig()
        self.config.generator_type = GeneratorType.AUTO_HW_CUSTOM_OP
        self.config.generation.use_autogenerated_base_classes = True
        
        self.generator = EnhancedHWCustomOpGenerator(self.config)
        
        # Create test RTL module
        self.rtl_module = self._create_test_rtl_module()
    
    def _create_test_rtl_module(self) -> RTLModule:
        """Create test RTL module."""
        signals = [
            RTLSignal("s_axis_input_tdata", "input", 32, interface_role="tdata"),
            RTLSignal("s_axis_input_tvalid", "input", 1, interface_role="tvalid"),
            RTLSignal("s_axis_input_tready", "output", 1, interface_role="tready"),
            RTLSignal("m_axis_output_tdata", "output", 32, interface_role="tdata"),
            RTLSignal("m_axis_output_tvalid", "output", 1, interface_role="tvalid"),
            RTLSignal("m_axis_output_tready", "input", 1, interface_role="tready")
        ]
        
        input_interface = RTLInterface("s_axis_input", "axi_stream", signals[:3])
        output_interface = RTLInterface("m_axis_output", "axi_stream", signals[3:])
        
        return RTLModule(
            name="test_accelerator",
            interfaces=[input_interface, output_interface],
            parameters={"DATA_WIDTH": 32, "BUFFER_DEPTH": 1024}
        )
    
    def test_generator_initialization(self):
        """Test generator initialization."""
        assert self.generator.config is not None
        assert self.generator.template_manager is not None
        assert self.generator.context_builder is not None
        assert GeneratorCapability.HW_CUSTOM_OP in self.generator.capabilities
        assert GeneratorCapability.DATAFLOW_INTEGRATION in self.generator.capabilities
    
    def test_get_template_name(self):
        """Test template name selection."""
        # Test slim mode
        self.config.generation.use_autogenerated_base_classes = True
        assert self.generator.get_template_name() == "hw_custom_op_slim.py.j2"
        
        # Test full mode
        self.config.generation.use_autogenerated_base_classes = False
        assert self.generator.get_template_name() == "hw_custom_op.py.j2"
    
    def test_get_artifact_type(self):
        """Test artifact type."""
        assert self.generator.get_artifact_type() == "hwcustomop"
    
    def test_validate_inputs_valid(self):
        """Test input validation with valid inputs."""
        inputs = {
            "rtl_module": self.rtl_module,
            "config": self.config
        }
        
        errors = self.generator.validate_inputs(inputs)
        assert len(errors) == 0
    
    def test_validate_inputs_missing_rtl_module(self):
        """Test input validation with missing RTL module."""
        inputs = {"config": self.config}
        
        errors = self.generator.validate_inputs(inputs)
        assert len(errors) > 0
        assert any("rtl_module" in error for error in errors)
    
    def test_validate_inputs_invalid_rtl_module(self):
        """Test input validation with invalid RTL module."""
        inputs = {
            "rtl_module": "invalid",
            "config": self.config
        }
        
        errors = self.generator.validate_inputs(inputs)
        assert len(errors) > 0
        assert any("Invalid rtl_module type" in error for error in errors)
    
    def test_validate_inputs_empty_interfaces(self):
        """Test input validation with empty interfaces."""
        empty_module = RTLModule("empty", [], {})
        inputs = {
            "rtl_module": empty_module,
            "config": self.config
        }
        
        errors = self.generator.validate_inputs(inputs)
        assert len(errors) > 0
        assert any("no interfaces" in error for error in errors)
    
    @patch('brainsmith.tools.hw_kernel_gen.generators.enhanced_hw_custom_op_generator.EnhancedTemplateManager')
    def test_generate_success(self, mock_template_manager):
        """Test successful generation."""
        # Mock template manager
        mock_template_manager.return_value.render_template.return_value = """
class TestAccelerator(AutoHWCustomOp):
    def __init__(self):
        super().__init__()
    
    def execute(self, context):
        return True
"""
        
        inputs = {
            "rtl_module": self.rtl_module,
            "config": self.config,
            "class_name": "TestAccelerator"
        }
        
        result = self.generator.generate(inputs)
        
        assert result.success
        assert len(result.artifacts) == 1
        assert result.artifacts[0].artifact_type == "hwcustomop"
        assert result.artifacts[0].file_name == "TestAccelerator.py"
        assert "TestAccelerator" in result.artifacts[0].content
        assert "enhanced_hw_custom_op" in result.metadata["generator"]
    
    def test_generate_with_validation_errors(self):
        """Test generation with validation errors."""
        inputs = {"invalid": "data"}
        
        result = self.generator.generate(inputs)
        
        assert not result.success
        assert len(result.errors) > 0
    
    def test_hw_kernel_to_rtl_module_conversion(self):
        """Test HWKernel to RTLModule conversion."""
        # Create mock HWKernel
        mock_hw_kernel = Mock()
        mock_hw_kernel.module_name = "test_module"
        mock_hw_kernel.interfaces = []
        mock_hw_kernel.parameters = {"WIDTH": 32}
        mock_hw_kernel.source_file = "test.sv"
        
        rtl_module = self.generator._hw_kernel_to_rtl_module(mock_hw_kernel)
        
        assert isinstance(rtl_module, RTLModule)
        assert rtl_module.name == "test_module"
        assert rtl_module.parameters == {"WIDTH": 32}
        assert rtl_module.source_file == "test.sv"
    
    def test_performance_metrics(self):
        """Test performance metrics tracking."""
        initial_metrics = self.generator.get_performance_metrics()
        assert initial_metrics["generation_count"] == 0
        
        # Mock successful generation
        self.generator._update_generation_metrics(0.1, True)
        
        updated_metrics = self.generator.get_performance_metrics()
        assert updated_metrics["generation_count"] == 1
        assert updated_metrics["total_generation_time"] == 0.1
        assert updated_metrics["average_generation_time"] == 0.1
    
    def test_factory_function(self):
        """Test factory function."""
        generator = create_enhanced_hw_custom_op_generator(self.config)
        assert isinstance(generator, EnhancedHWCustomOpGenerator)
        assert generator.config is self.config
    
    def test_legacy_compatibility_function(self):
        """Test legacy compatibility wrapper."""
        with patch.object(EnhancedHWCustomOpGenerator, 'generate') as mock_generate:
            mock_result = GenerationResult(success=True)
            mock_result.add_artifact(GeneratedArtifact("test.py", "content", "hwcustomop"))
            mock_generate.return_value = mock_result
            
            result = generate_enhanced_hwcustomop(
                rtl_module=self.rtl_module,
                config=self.config,
                class_name="TestClass"
            )
            
            assert isinstance(result, GenerationResult)
            mock_generate.assert_called_once()


class TestEnhancedRTLBackendGenerator:
    """Test enhanced RTL Backend generator."""
    
    def setup_method(self):
        """Set up test fixtures."""
        self.config = PipelineConfig()
        self.config.generator_type = GeneratorType.AUTO_RTL_BACKEND
        self.config.generation.use_autogenerated_base_classes = True
        self.config.dataflow.resource_estimation_enabled = True
        self.config.optimization_enabled = True
        
        self.generator = EnhancedRTLBackendGenerator(self.config)
        
        # Create test RTL module with AXI interfaces
        self.rtl_module = self._create_test_rtl_module()
    
    def _create_test_rtl_module(self) -> RTLModule:
        """Create test RTL module with AXI interfaces."""
        # AXI Stream interface
        axi_signals = [
            RTLSignal("s_axis_tdata", "input", 32, interface_role="tdata"),
            RTLSignal("s_axis_tvalid", "input", 1, interface_role="tvalid"),
            RTLSignal("s_axis_tready", "output", 1, interface_role="tready"),
            RTLSignal("s_axis_tlast", "input", 1, interface_role="tlast")
        ]
        axi_interface = RTLInterface("s_axis", "axi_stream", axi_signals)
        
        # AXI Lite interface
        axilite_signals = [
            RTLSignal("s_axilite_awaddr", "input", 32, interface_role="awaddr"),
            RTLSignal("s_axilite_awvalid", "input", 1, interface_role="awvalid"),
            RTLSignal("s_axilite_awready", "output", 1, interface_role="awready"),
            RTLSignal("s_axilite_wdata", "input", 32, interface_role="wdata")
        ]
        axilite_interface = RTLInterface("s_axilite", "axi_lite", axilite_signals)
        
        return RTLModule(
            name="rtl_backend_test",
            interfaces=[axi_interface, axilite_interface],
            parameters={"DATA_WIDTH": 32, "ADDR_WIDTH": 32}
        )
    
    def test_generator_initialization(self):
        """Test generator initialization."""
        assert self.generator.config is not None
        assert self.generator.template_manager is not None
        assert self.generator.context_builder is not None
        assert GeneratorCapability.RTL_BACKEND in self.generator.capabilities
        assert GeneratorCapability.DATAFLOW_INTEGRATION in self.generator.capabilities
        assert GeneratorCapability.OPTIMIZATION in self.generator.capabilities
    
    def test_get_template_name(self):
        """Test template name selection."""
        # Test slim mode
        self.config.generation.use_autogenerated_base_classes = True
        assert self.generator.get_template_name() == "rtl_backend_slim.py.j2"
        
        # Test full mode
        self.config.generation.use_autogenerated_base_classes = False
        assert self.generator.get_template_name() == "rtl_backend.py.j2"
    
    def test_get_artifact_type(self):
        """Test artifact type."""
        assert self.generator.get_artifact_type() == "rtlbackend"
    
    def test_validate_inputs_valid(self):
        """Test input validation with valid AXI interfaces."""
        inputs = {
            "rtl_module": self.rtl_module,
            "config": self.config
        }
        
        errors = self.generator.validate_inputs(inputs)
        assert len(errors) == 0
    
    def test_validate_inputs_no_axi_interfaces(self):
        """Test input validation with no AXI interfaces."""
        # Create module with non-AXI interfaces
        signals = [RTLSignal("data", "input", 32)]
        interface = RTLInterface("simple", "custom", signals)
        bad_module = RTLModule(name="bad", interfaces=[interface], parameters={})
        
        inputs = {
            "rtl_module": bad_module,
            "config": self.config
        }
        
        errors = self.generator.validate_inputs(inputs)
        assert len(errors) > 0
        assert any("AXI interfaces" in error for error in errors)
    
    def test_interface_optimization(self):
        """Test interface optimization."""
        optimized = self.generator._optimize_interfaces(self.rtl_module.interfaces)
        
        assert "stream_interfaces" in optimized
        assert "control_interfaces" in optimized
        assert "optimization_applied" in optimized
        
        # Should have found AXI Stream interface
        assert len(optimized["stream_interfaces"]) > 0
        assert optimized["stream_interfaces"][0]["name"] == "s_axis"
        assert optimized["stream_interfaces"][0]["data_width"] == 32
        
        # Should have found AXI Lite interface
        assert len(optimized["control_interfaces"]) > 0
        assert optimized["control_interfaces"][0]["name"] == "s_axilite"
    
    def test_resource_estimation(self):
        """Test FPGA resource estimation."""
        estimates = self.generator._estimate_resources(self.rtl_module, {})
        
        assert "luts" in estimates
        assert "flip_flops" in estimates
        assert "dsps" in estimates
        assert "brams" in estimates
        assert estimates["luts"] > 0
        assert estimates["flip_flops"] > 0
        assert estimates["estimation_method"] == "heuristic"
    
    def test_performance_config_generation(self):
        """Test performance monitoring configuration."""
        perf_config = self.generator._generate_performance_config(self.rtl_module)
        
        assert perf_config["enable_cycle_counting"]
        assert perf_config["enable_throughput_monitoring"]
        assert perf_config["enable_latency_measurement"]
        assert len(perf_config["performance_counters"]) > 0
    
    @patch('brainsmith.tools.hw_kernel_gen.generators.enhanced_rtl_backend_generator.EnhancedTemplateManager')
    def test_generate_success(self, mock_template_manager):
        """Test successful generation."""
        # Mock template manager
        mock_template_manager.return_value.render_template.return_value = """
class RtlBackendTestRTLBackend(AutoRTLBackend):
    def __init__(self):
        super().__init__()
    
    def execute(self, inputs):
        return True
"""
        mock_template_manager.return_value.template_exists.return_value = True
        
        inputs = {
            "rtl_module": self.rtl_module,
            "config": self.config,
            "backend_class_name": "TestRTLBackend"
        }
        
        result = self.generator.generate(inputs)
        
        assert result.success
        assert len(result.artifacts) >= 1  # May include docs and wrapper
        
        # Check primary artifact
        primary_artifact = result.artifacts[0]
        assert primary_artifact.artifact_type == "rtlbackend"
        assert "TestRTLBackend" in primary_artifact.file_name
        assert "enhanced_rtl_backend" in result.metadata["generator"]
        assert result.metadata["optimization_applied"]
    
    def test_generate_with_additional_artifacts(self):
        """Test generation with documentation and wrapper artifacts."""
        with patch.object(self.generator.template_manager, 'render_template') as mock_render:
            with patch.object(self.generator.template_manager, 'template_exists') as mock_exists:
                # Mock template existence
                mock_exists.return_value = True
                
                # Mock template rendering
                mock_render.side_effect = [
                    "# RTL Backend class content",  # Main artifact
                    "# Documentation content",      # Documentation
                    "// Verilog wrapper content"   # Wrapper
                ]
                
                inputs = {
                    "rtl_module": self.rtl_module,
                    "generate_wrapper": True
                }
                
                result = self.generator.generate(inputs)
                
                assert result.success
                assert len(result.artifacts) == 3  # Backend + docs + wrapper
                
                artifact_types = [art.artifact_type for art in result.artifacts]
                assert "rtlbackend" in artifact_types
                assert "documentation" in artifact_types
                assert "wrapper" in artifact_types
    
    def test_optimization_application(self):
        """Test optimization application to context."""
        from brainsmith.tools.hw_kernel_gen.enhanced_template_context import RTLBackendContext
        
        # Create mock context
        context = RTLBackendContext(
            rtl_module=self.rtl_module,
            config=self.config,
            config_metadata={},
            custom_data={}
        )
        
        optimized_context = self.generator._apply_optimizations(context, {})
        
        assert "optimized_interfaces" in optimized_context.custom_data
        assert "resource_estimates" in optimized_context.custom_data
        assert "performance_config" in optimized_context.custom_data
        assert self.generator._optimization_count > 0
    
    def test_factory_function(self):
        """Test factory function."""
        generator = create_enhanced_rtl_backend_generator(self.config)
        assert isinstance(generator, EnhancedRTLBackendGenerator)
        assert generator.config is self.config
    
    def test_legacy_compatibility_function(self):
        """Test legacy compatibility wrapper."""
        with patch.object(EnhancedRTLBackendGenerator, 'generate') as mock_generate:
            mock_result = GenerationResult(success=True)
            mock_result.add_artifact(GeneratedArtifact("backend.py", "content", "rtlbackend"))
            mock_generate.return_value = mock_result
            
            result = generate_enhanced_rtlbackend(
                rtl_module=self.rtl_module,
                config=self.config,
                backend_class_name="TestBackend"
            )
            
            assert isinstance(result, GenerationResult)
            mock_generate.assert_called_once()
    
    def test_dataflow_mode_support(self):
        """Test dataflow mode support."""
        assert self.generator.supports_dataflow_mode()
    
    def test_configuration_requirements(self):
        """Test configuration requirements."""
        requirements = self.generator.get_configuration_requirements()
        
        assert "required_config_sections" in requirements
        assert "template" in requirements["required_config_sections"]
        assert "generation" in requirements["required_config_sections"]
        assert "dataflow" in requirements["required_config_sections"]
        
        assert "required_templates" in requirements
        assert "optional_inputs" in requirements
        assert "output_artifacts" in requirements


class TestEnhancedGeneratorIntegration:
    """Test integration between enhanced generators."""
    
    def setup_method(self):
        """Set up integration test fixtures."""
        self.config = PipelineConfig()
        self.config.generation.use_autogenerated_base_classes = True
        self.config.dataflow.mode = DataflowMode.HYBRID
        
        self.hw_generator = EnhancedHWCustomOpGenerator(self.config)
        self.rtl_generator = EnhancedRTLBackendGenerator(self.config)
        
        self.rtl_module = self._create_comprehensive_rtl_module()
    
    def _create_comprehensive_rtl_module(self) -> RTLModule:
        """Create comprehensive RTL module for integration testing."""
        # Input interface
        input_signals = [
            RTLSignal("s_axis_input_tdata", "input", 64, interface_role="tdata"),
            RTLSignal("s_axis_input_tvalid", "input", 1, interface_role="tvalid"),
            RTLSignal("s_axis_input_tready", "output", 1, interface_role="tready"),
            RTLSignal("s_axis_input_tlast", "input", 1, interface_role="tlast")
        ]
        input_interface = RTLInterface("s_axis_input", "axi_stream", input_signals)
        
        # Output interface
        output_signals = [
            RTLSignal("m_axis_output_tdata", "output", 32, interface_role="tdata"),
            RTLSignal("m_axis_output_tvalid", "output", 1, interface_role="tvalid"),
            RTLSignal("m_axis_output_tready", "input", 1, interface_role="tready"),
            RTLSignal("m_axis_output_tlast", "output", 1, interface_role="tlast")
        ]
        output_interface = RTLInterface("m_axis_output", "axi_stream", output_signals)
        
        # Control interface
        control_signals = [
            RTLSignal("s_axilite_awaddr", "input", 32, interface_role="awaddr"),
            RTLSignal("s_axilite_awvalid", "input", 1, interface_role="awvalid"),
            RTLSignal("s_axilite_awready", "output", 1, interface_role="awready")
        ]
        control_interface = RTLInterface("s_axilite", "axi_lite", control_signals)
        
        return RTLModule(
            name="comprehensive_accelerator",
            interfaces=[input_interface, output_interface, control_interface],
            parameters={
                "INPUT_WIDTH": 64,
                "OUTPUT_WIDTH": 32,
                "BUFFER_DEPTH": 1024,
                "ENABLE_BACKPRESSURE": True
            }
        )
    
    def test_generator_capability_compatibility(self):
        """Test that generators have compatible capabilities."""
        hw_caps = self.hw_generator.get_capabilities()
        rtl_caps = self.rtl_generator.get_capabilities()
        
        # Both should support dataflow integration
        assert GeneratorCapability.DATAFLOW_INTEGRATION in hw_caps
        assert GeneratorCapability.DATAFLOW_INTEGRATION in rtl_caps
        
        # Both should support validation
        assert GeneratorCapability.VALIDATION in hw_caps
        assert GeneratorCapability.VALIDATION in rtl_caps
    
    @patch('brainsmith.tools.hw_kernel_gen.generators.enhanced_hw_custom_op_generator.EnhancedTemplateManager')
    @patch('brainsmith.tools.hw_kernel_gen.generators.enhanced_rtl_backend_generator.EnhancedTemplateManager')
    def test_sequential_generation(self, mock_rtl_tm, mock_hw_tm):
        """Test sequential generation of HW Custom Op and RTL Backend."""
        # Mock template managers
        mock_hw_tm.return_value.render_template.return_value = "# HW Custom Op content"
        mock_rtl_tm.return_value.render_template.return_value = "# RTL Backend content"
        mock_rtl_tm.return_value.template_exists.return_value = False  # Skip additional artifacts
        
        # Generate HW Custom Op first
        hw_inputs = {
            "rtl_module": self.rtl_module,
            "class_name": "ComprehensiveAccelerator"
        }
        hw_result = self.hw_generator.generate(hw_inputs)
        
        assert hw_result.success
        assert len(hw_result.artifacts) == 1
        hw_artifact = hw_result.artifacts[0]
        assert hw_artifact.artifact_type == "hwcustomop"
        
        # Generate RTL Backend using same module
        rtl_inputs = {
            "rtl_module": self.rtl_module,
            "backend_class_name": "ComprehensiveAcceleratorRTLBackend"
        }
        rtl_result = self.rtl_generator.generate(rtl_inputs)
        
        assert rtl_result.success
        assert len(rtl_result.artifacts) >= 1
        rtl_artifact = rtl_result.artifacts[0]
        assert rtl_artifact.artifact_type == "rtlbackend"
        
        # Verify metadata consistency
        assert hw_result.metadata["dataflow_enabled"] == rtl_result.metadata["dataflow_enabled"]
        assert hw_result.metadata["slim_mode"] == rtl_result.metadata["slim_mode"]
    
    def test_performance_metrics_tracking(self):
        """Test performance metrics across both generators."""
        # Get initial metrics
        hw_initial = self.hw_generator.get_performance_metrics()
        rtl_initial = self.rtl_generator.get_performance_metrics()
        
        assert hw_initial["generation_count"] == 0
        assert rtl_initial["generation_count"] == 0
        
        # Simulate generation
        self.hw_generator._update_generation_metrics(0.1, True)
        self.rtl_generator._update_generation_metrics(0.15, True)
        
        # Check updated metrics
        hw_updated = self.hw_generator.get_performance_metrics()
        rtl_updated = self.rtl_generator.get_performance_metrics()
        
        assert hw_updated["generation_count"] == 1
        assert rtl_updated["generation_count"] == 1
        assert hw_updated["average_generation_time"] == 0.1
        assert rtl_updated["average_generation_time"] == 0.15
    
    def test_configuration_consistency(self):
        """Test configuration consistency across generators."""
        # Both generators should have same config
        assert self.hw_generator.config is self.config
        assert self.rtl_generator.config is self.config
        
        # Both should respect same settings
        assert self.hw_generator.get_template_name().endswith("_slim.py.j2")
        assert self.rtl_generator.get_template_name().endswith("_slim.py.j2")
        
        # Both should support dataflow mode
        assert self.hw_generator.supports_dataflow_mode()
        assert self.rtl_generator.supports_dataflow_mode()


if __name__ == "__main__":
    pytest.main([__file__, "-v"])