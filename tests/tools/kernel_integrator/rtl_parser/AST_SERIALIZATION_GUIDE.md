# AST Serialization Test - User Guide

## Overview

The AST Serialization Test provides a way to visualize and verify the Abstract Syntax Tree (AST) generated by the RTL parser. This is particularly useful for:
- Understanding how the parser interprets SystemVerilog code
- Debugging parsing issues
- Regression testing parser changes
- Creating test cases for new RTL constructs

## Quick Start

### 1. Running Basic Tests

```bash
# Run all AST serialization tests
./smithy "python -m pytest tests/tools/kernel_integrator/rtl_parser/test_ast_serialization.py -v"

# Run a specific test
./smithy "python -m pytest tests/tools/kernel_integrator/rtl_parser/test_ast_serialization.py::TestASTSerialization::test_simple_module_serialization -v -s"
```

### 2. Parsing Your Own RTL File

Create a simple Python script or use the command line:

```bash
./smithy "python -c \"
from pathlib import Path
from brainsmith.tools.kernel_integrator.rtl_parser.ast_parser import ASTParser
from tests.tools.kernel_integrator.rtl_parser.utils.ast_serializer import ASTSerializer

# Parse your RTL file
parser = ASTParser()
with open('path/to/your/module.sv', 'r') as f:
    content = f.read()
    
tree = parser.parse_source(content)

# Serialize to tree format
serializer = ASTSerializer()
print(serializer.serialize_tree(tree, format='tree'))
\""
```

## AST Output Formats

### 1. Tree Format (Default)
Shows hierarchical structure with visual connectors:

```
└── source_file [0:0-15:9]
    └── module_declaration [6:0-15:9]
        ├── module_ansi_header [6:0-10:2]
        │   ├── module_keyword "module" [6:0-6:6]
        │   ├── simple_identifier "simple_module" [6:7-6:20]
        │   └── list_of_port_declarations [6:21-10:1]
        │       ├── ansi_port_declaration "input logic clk" [7:4-7:27]
        │       └── ansi_port_declaration "output logic [7:0] data_out" [9:4-9:32]
        └── endmodule "endmodule" [15:0-15:9]
```

### 2. JSON Format
Structured data for programmatic processing:

```json
{
  "type": "source_file",
  "text": "",
  "start": "0:0",
  "end": "15:9",
  "children": [
    {
      "type": "module_declaration",
      "text": "module simple_module...",
      "start": "6:0",
      "end": "15:9",
      "children": [...]
    }
  ]
}
```

### 3. Compact Format
Single-line representation for quick comparisons:

```
source_file [0:0-15:9] (module_declaration "module simple_module..." [6:0-15:9] (...))
```

## Customization Options

### AST Serializer Configuration

```python
from tests.tools.kernel_integrator.rtl_parser.utils.ast_serializer import ASTSerializer

# Create serializer with custom options
serializer = ASTSerializer(
    max_depth=5,              # Limit tree depth (None for unlimited)
    max_text_length=30,       # Truncate long text
    include_positions=True,   # Include line:col positions
    exclude_types={'comment'} # Exclude specific node types
)
```

### Common Use Cases

#### 1. Debug Pragma Parsing
```python
# Include comments to see pragmas
serializer = ASTSerializer(exclude_types=set())  # Don't exclude anything
tree_with_comments = serializer.serialize_tree(tree, format='tree')
```

#### 2. Focus on Module Structure
```python
# Exclude implementation details
serializer = ASTSerializer(
    exclude_types={'always_ff', 'initial', 'final', 'comment', 'assign'}
)
structure_only = serializer.serialize_tree(tree, format='tree')
```

#### 3. Compare Two AST Trees
```python
from tests.tools.kernel_integrator.rtl_parser.utils.ast_serializer import ASTDiffer

differ = ASTDiffer(ignore_positions=True)
differences = differ.compare_trees(tree1, tree2)

for diff in differences:
    print(f"Difference: {diff}")
```

## Creating Test Cases

### Step 1: Create RTL Test File
Place your RTL file in `tests/tools/kernel_integrator/rtl_parser/fixtures/ast_comparison/`:

```systemverilog
// my_test_module.sv
module my_test_module #(
    parameter WIDTH = 8
) (
    input  logic clk,
    output logic [WIDTH-1:0] data
);
    // Implementation
endmodule
```

### Step 2: Generate Expected Output
```bash
./smithy "python -c \"
from pathlib import Path
from brainsmith.tools.kernel_integrator.rtl_parser.ast_parser import ASTParser
from tests.tools.kernel_integrator.rtl_parser.utils.ast_serializer import ASTSerializer

# Parse and generate expected output
parser = ASTParser()
serializer = ASTSerializer(max_text_length=50)

rtl_file = Path('tests/tools/kernel_integrator/rtl_parser/fixtures/ast_comparison/my_test_module.sv')
with open(rtl_file, 'r') as f:
    tree = parser.parse_source(f.read())
    
# Save expected output
output_file = rtl_file.with_name(rtl_file.stem + '_expected.tree')
serializer.serialize_to_file(tree, str(output_file), format='tree')
print(f'Created: {output_file}')
\""
```

### Step 3: Add Test Method
Add to `test_ast_serialization.py`:

```python
def test_my_module_serialization(self, ast_parser, ast_comparison_dir, output_dir):
    """Test serializing my custom module."""
    rtl_file = ast_comparison_dir / "my_test_module.sv"
    expected_file = ast_comparison_dir / "my_test_module_expected.tree"
    
    # Parse RTL
    with open(rtl_file, 'r') as f:
        tree = ast_parser.parse_source(f.read())
    
    # Serialize
    serializer = ASTSerializer(max_text_length=50)
    actual = serializer.serialize_tree(tree, format='tree')
    
    # Compare with expected
    with open(expected_file, 'r') as f:
        expected = f.read()
    
    assert actual == expected, "AST output doesn't match expected"
```

## Troubleshooting

### Common Issues

1. **Parser Fails to Load Grammar**
   - Ensure `sv.so` file exists in the rtl_parser directory
   - Check file permissions

2. **AST Has Unexpected Structure**
   - Use tree format with full depth to see complete structure
   - Check for syntax errors using `tree.root_node.has_error`

3. **Pragma Comments Not Visible**
   - Ensure `exclude_types` doesn't contain 'comment'
   - Comments are parsed as separate nodes, not part of declarations

### Debugging Tips

1. **Enable Debug Output**:
   ```python
   parser = ASTParser(debug=True)
   ```

2. **Check for Errors**:
   ```python
   if tree.root_node.has_error:
       error = parser.find_first_error_node(tree.root_node)
       print(f"Error at {error.start_point}: {error.type}")
   ```

3. **Inspect Specific Nodes**:
   ```python
   # Find all module declarations
   modules = parser.find_modules(tree)
   for module in modules:
       print(f"Module: {module.text.decode('utf-8')[:50]}...")
   ```

## Advanced Usage

### Custom Tree Traversal
```python
def find_all_parameters(node):
    """Find all parameter declarations in AST."""
    parameters = []
    
    def traverse(n):
        if n.type == "parameter_port_declaration":
            parameters.append(n)
        for child in n.children:
            traverse(child)
    
    traverse(node)
    return parameters

# Usage
params = find_all_parameters(tree.root_node)
for param in params:
    print(f"Parameter: {param.text.decode('utf-8')}")
```

### Batch Processing
```python
# Process all RTL files in a directory
from pathlib import Path

rtl_dir = Path("path/to/rtl/files")
output_dir = Path("path/to/output")

for rtl_file in rtl_dir.glob("*.sv"):
    with open(rtl_file, 'r') as f:
        tree = parser.parse_source(f.read())
    
    output_file = output_dir / f"{rtl_file.stem}_ast.tree"
    serializer.serialize_to_file(tree, str(output_file))
    print(f"Processed: {rtl_file.name}")
```

## Integration with Other Tools

### Generating FINN Operator Metadata
The AST can be used to extract information for FINN operator generation:

```python
# Extract interface information from AST
def extract_interfaces(tree):
    """Extract AXI-Stream interfaces from AST."""
    interfaces = []
    # ... traverse AST to find interface patterns
    return interfaces

# Use in kernel integration workflow
interfaces = extract_interfaces(tree)
for intf in interfaces:
    print(f"Found interface: {intf}")
```

## Best Practices

1. **Version Control**: Include expected AST files in version control for regression testing
2. **Consistent Formatting**: Use the same serializer settings for expected and actual output
3. **Meaningful Names**: Name test files descriptively (e.g., `axi_stream_with_sideband.sv`)
4. **Document Changes**: Update expected files when parser behavior intentionally changes
5. **Test Edge Cases**: Include malformed RTL to verify error handling

## Further Reading

- [RTL Parser Architecture](../rtl_parser/ARCHITECTURE.md)
- [Pragma Guide](../rtl_parser/PRAGMA_GUIDE.md)
- [Tree-sitter Documentation](https://tree-sitter.github.io/tree-sitter/)