"""
Report Generator for Brainsmith Repository Audit

Generates human-readable reports from audit results.
"""

import json
import time
from pathlib import Path
from typing import Dict, Any, List
from datetime import datetime

class ReportGenerator:
    """Generates audit reports in various formats."""
    
    def __init__(self, results: Dict[str, Any], issues: List[Dict[str, Any]]):
        self.results = results
        self.issues = issues
        self.timestamp = datetime.now()
        
    def generate_audit_report(self):
        """Generate main audit report in Markdown format."""
        report_path = Path('audit/reports/audit_report.md')
        
        with open(report_path, 'w') as f:
            f.write(self._generate_report_content())
        
        print(f"ðŸ“‹ Audit report generated: {report_path}")
    
    def generate_recommendations(self):
        """Generate recommendations based on audit results."""
        recommendations_path = Path('audit/reports/recommendations.md')
        
        with open(recommendations_path, 'w') as f:
            f.write(self._generate_recommendations_content())
        
        print(f"ðŸ’¡ Recommendations generated: {recommendations_path}")
    
    def _generate_report_content(self) -> str:
        """Generate the main audit report content."""
        summary = self.results.get('summary', {})
        
        content = f"""# Brainsmith Repository Audit Report

**Generated**: {self.timestamp.strftime('%Y-%m-%d %H:%M:%S')}  
**Execution Time**: {self.results.get('execution_time', 0):.2f} seconds  

## Executive Summary

- **Total Tests**: {summary.get('total_tests', 0)}
- **Passed Tests**: {summary.get('passed_tests', 0)}
- **Failed Tests**: {summary.get('failed_tests', 0)}
- **Success Rate**: {summary.get('success_rate_percent', 0):.1f}%
- **Overall Status**: {summary.get('overall_status', 'UNKNOWN')}
- **Critical Issues**: {summary.get('critical_issues', 0)}
- **Total Issues**: {summary.get('total_issues', 0)}

## Phase 1: Functional Completeness Audit

### Core Layer Results
{self._format_test_results(self.results.get('phase1', {}).get('core_layer', {}))}

### Infrastructure Layer Results
{self._format_test_results(self.results.get('phase1', {}).get('infrastructure_layer', {}))}

### Libraries Layer Results
{self._format_test_results(self.results.get('phase1', {}).get('libraries_layer', {}))}

## Phase 2: Integration Testing

### Cross-Layer Integration
{self._format_test_results(self.results.get('phase2', {}).get('cross_layer_integration', {}))}

### Blueprint Management Integration
{self._format_test_results(self.results.get('phase2', {}).get('blueprint_management_integration', {}))}

### Registry Integration
{self._format_test_results(self.results.get('phase2', {}).get('registry_integration', {}))}

### Import Dependency Health
{self._format_test_results(self.results.get('phase2', {}).get('import_dependency_health', {}))}

## Phase 3: Extension Mechanisms Audit

### Registry Auto-Discovery
{self._format_test_results(self.results.get('phase3', {}).get('registry_auto_discovery', {}))}

### Contrib Directory Structure
{self._format_test_results(self.results.get('phase3', {}).get('contrib_directory_structure', {}))}

### Plugin System Validation
{self._format_test_results(self.results.get('phase3', {}).get('plugin_system_validation', {}))}

### Extension Point Testing
{self._format_test_results(self.results.get('phase3', {}).get('extension_point_testing', {}))}

## Issues Found

{self._format_issues()}

## Recommendations

{self._generate_quick_recommendations()}

---
*Report generated by Brainsmith Repository Audit System*
"""
        return content
    
    def _format_test_results(self, results: Dict[str, Any]) -> str:
        """Format test results for display."""
        if not results:
            return "No results available.\n"
        
        content = ""
        for test_name, test_result in results.items():
            if isinstance(test_result, dict):
                status = "âœ… PASS" if test_result.get('passed', False) else "âŒ FAIL"
                content += f"- **{test_name}**: {status}\n"
                
                if 'test_cases' in test_result:
                    for case_name, case_result in test_result['test_cases'].items():
                        if isinstance(case_result, dict):
                            case_status = "âœ…" if case_result.get('passed', False) else "âŒ"
                            description = case_result.get('description', 'No description')
                            content += f"  - {case_name}: {case_status} {description}\n"
                
                if test_result.get('issues'):
                    content += f"  - Issues: {len(test_result['issues'])} found\n"
        
        return content + "\n"
    
    def _format_issues(self) -> str:
        """Format issues for display."""
        if not self.issues:
            return "No issues found. âœ…\n"
        
        content = ""
        severity_order = ['critical', 'high', 'medium', 'low']
        
        for severity in severity_order:
            severity_issues = [issue for issue in self.issues if issue.get('severity') == severity]
            if severity_issues:
                content += f"\n### {severity.upper()} Issues\n\n"
                for issue in severity_issues:
                    content += f"- **{issue.get('component', 'Unknown')}**: {issue.get('description', 'No description')}\n"
        
        return content + "\n"
    
    def _generate_quick_recommendations(self) -> str:
        """Generate quick recommendations based on results."""
        recommendations = []
        summary = self.results.get('summary', {})
        
        success_rate = summary.get('success_rate_percent', 0)
        
        if success_rate < 50:
            recommendations.append("ðŸš¨ **URGENT**: Success rate below 50%. Immediate attention required for core functionality.")
        elif success_rate < 75:
            recommendations.append("âš ï¸ **WARNING**: Success rate below 75%. Several components need fixes.")
        elif success_rate < 90:
            recommendations.append("ðŸ“ **IMPROVE**: Success rate below 90%. Minor improvements needed.")
        else:
            recommendations.append("âœ… **EXCELLENT**: High success rate. System is functioning well.")
        
        if summary.get('critical_issues', 0) > 0:
            recommendations.append(f"ðŸ”¥ **CRITICAL**: {summary.get('critical_issues')} critical issues must be resolved immediately.")
        
        # Check specific patterns in results
        phase1_results = self.results.get('phase1', {})
        if not phase1_results.get('core_layer', {}).get('passed', True):
            recommendations.append("ðŸŽ¯ **CORE**: Core layer issues detected. Priority: High")
        
        if not self.results.get('phase2', {}).get('blueprint_management_integration', {}).get('passed', True):
            recommendations.append("ðŸ“‹ **BLUEPRINTS**: Blueprint management integration needs attention.")
        
        if not self.results.get('phase3', {}).get('contrib_directory_structure', {}).get('passed', True):
            recommendations.append("ðŸ“ **CONTRIB**: Contrib directory structure needs setup for extensions.")
        
        if not recommendations:
            recommendations.append("âœ… All systems operational. No immediate action required.")
        
        return "\n".join(f"{i+1}. {rec}" for i, rec in enumerate(recommendations)) + "\n"
    
    def _generate_recommendations_content(self) -> str:
        """Generate detailed recommendations content."""
        content = f"""# Brainsmith Repository Audit Recommendations

**Generated**: {self.timestamp.strftime('%Y-%m-%d %H:%M:%S')}  

## Priority Actions

{self._generate_priority_actions()}

## Detailed Recommendations by Component

{self._generate_component_recommendations()}

## Extension Readiness Assessment

{self._generate_extension_readiness()}

## Next Steps

{self._generate_next_steps()}

---
*Recommendations generated by Brainsmith Repository Audit System*
"""
        return content
    
    def _generate_priority_actions(self) -> str:
        """Generate priority actions based on issues."""
        critical_issues = [issue for issue in self.issues if issue.get('severity') == 'critical']
        high_issues = [issue for issue in self.issues if issue.get('severity') == 'high']
        
        content = ""
        
        if critical_issues:
            content += "### ðŸš¨ CRITICAL - Immediate Action Required\n\n"
            for issue in critical_issues:
                content += f"- **{issue.get('component')}**: {issue.get('description')}\n"
            content += "\n"
        
        if high_issues:
            content += "### âš ï¸ HIGH PRIORITY - Address Within 24 Hours\n\n"
            for issue in high_issues:
                content += f"- **{issue.get('component')}**: {issue.get('description')}\n"
            content += "\n"
        
        if not critical_issues and not high_issues:
            content += "### âœ… No Critical Issues\n\nNo immediate action required. System is functioning well.\n\n"
        
        return content
    
    def _generate_component_recommendations(self) -> str:
        """Generate recommendations by component."""
        components = ['core_layer', 'infrastructure_layer', 'libraries_layer', 'integration', 'extensions']
        
        content = ""
        for component in components:
            content += f"### {component.replace('_', ' ').title()}\n\n"
            
            # Find issues for this component
            component_issues = [issue for issue in self.issues if component.replace('_', '') in issue.get('component', '').lower()]
            
            if component_issues:
                for issue in component_issues:
                    content += f"- {issue.get('description')}\n"
            else:
                content += "- No specific issues found for this component.\n"
            
            content += "\n"
        
        return content
    
    def _generate_extension_readiness(self) -> str:
        """Generate extension readiness assessment."""
        phase3_results = self.results.get('phase3', {})
        
        contrib_ready = phase3_results.get('contrib_directory_structure', {}).get('passed', False)
        registry_ready = phase3_results.get('registry_auto_discovery', {}).get('passed', False)
        plugin_ready = phase3_results.get('plugin_system_validation', {}).get('passed', False)
        extension_ready = phase3_results.get('extension_point_testing', {}).get('passed', False)
        
        readiness_score = sum([contrib_ready, registry_ready, plugin_ready, extension_ready]) / 4 * 100
        
        content = f"""### Overall Extension Readiness: {readiness_score:.0f}%

- **Contrib Directories**: {'âœ… Ready' if contrib_ready else 'âŒ Not Ready'}
- **Registry Auto-Discovery**: {'âœ… Working' if registry_ready else 'âŒ Issues Found'}
- **Plugin System**: {'âœ… Functional' if plugin_ready else 'âŒ Needs Work'}
- **Extension Points**: {'âœ… Available' if extension_ready else 'âŒ Limited'}

"""
        
        if readiness_score >= 75:
            content += "**Assessment**: System is ready for extensions and contributions.\n\n"
        elif readiness_score >= 50:
            content += "**Assessment**: System partially ready. Some components need attention.\n\n"
        else:
            content += "**Assessment**: Extension framework needs significant work before stakeholder contributions.\n\n"
        
        return content
    
    def _generate_next_steps(self) -> str:
        """Generate next steps based on audit results."""
        success_rate = self.results.get('summary', {}).get('success_rate_percent', 0)
        
        if success_rate >= 90:
            return """### Maintenance Phase
1. Monitor system performance
2. Update documentation
3. Prepare for stakeholder onboarding
4. Set up continuous integration testing

"""
        elif success_rate >= 75:
            return """### Improvement Phase
1. Address remaining test failures
2. Fix medium priority issues
3. Enhance extension mechanisms
4. Update documentation

"""
        else:
            return """### Stabilization Phase
1. Fix critical and high priority issues
2. Re-run audit to verify fixes
3. Focus on core functionality stability
4. Postpone extension work until core is stable

"""