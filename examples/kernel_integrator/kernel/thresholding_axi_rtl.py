# Auto-generated by Brainsmith Kernel Integrator for thresholding_axi
# Generated from: /home/tafk/dev/brainsmith-1/examples/kernel_integrator/source/thresholding_axi.sv

import os
from pathlib import Path

from thresholding_axi import ThresholdingAxi

from brainsmith._internal.finn.auto_rtl_backend import AutoRTLBackend


class ThresholdingAxi_rtl(ThresholdingAxi, AutoRTLBackend):
    """
    RTL backend for thresholding_axi operation.

    Auto-generated from SystemVerilog RTL: /home/tafk/dev/brainsmith-1/examples/kernel_integrator/source/thresholding_axi.sv
    Uses direct parameter resolution from KernelMetadata structure.
    """

    def __init__(self, onnx_node, **kwargs):
        """Initialize thresholding_axi_rtl backend."""
        super().__init__(onnx_node, **kwargs)

    def get_nodeattr_types(self):
        """
        Define all node attributes including RTL-specific parameters.

        Inherits interface attributes from HWCustomOp parent and adds
        RTL-specific algorithm parameters.
        """
        # Get interface datatype attributes from HWCustomOp parent
        my_attrs = super().get_nodeattr_types()

        # Add RTL-specific algorithm parameters
        rtl_attrs = {
            "input_FPARG": ("i", True, None),
            "BIAS": ("i", True, None),
            "THRESHOLDS_PATH": ("s", True, ""),
            "DEPTH_TRIGGER_URAM": ("i", True, None),
            "DEPTH_TRIGGER_BRAM": ("i", True, None),
            "DEEP_PIPELINE": ("i", True, None),
            # Configuration interface parameters
            "width": ("i", True, None),
            # AXI-Lite enable parameter
            "USE_AXILITE": ("i", True, 1),  # Has AXI-Lite config interface
            # Threshold datatype parameter
            "thresholdDataType": ("s", True, "INT8"),  # Default threshold datatype
        }
        my_attrs.update(rtl_attrs)

        # Add HDL generation attributes
        my_attrs.update(
            {
                "gen_top_module": ("s", False, ""),
                "ipgen_path": ("s", False, ""),
                "ip_path": ("s", False, ""),
            }
        )

        return my_attrs

    def prepare_codegen_rtl_values(self, model):
        """
        Prepare parameter values for RTL code generation.

        Maps node attributes and interface properties to RTL template variables.
        Uses direct access to generate clear, traceable mappings.
        """
        code_gen_dict = {}

        # Basic module information
        code_gen_dict["$MODULE_NAME_AXI_WRAPPER$"] = [self.get_verilog_top_module_name()]
        code_gen_dict["$TOP_MODULE$"] = code_gen_dict["$MODULE_NAME_AXI_WRAPPER$"]

        # Standard stream width variables
        code_gen_dict["$IBITS$"] = [str(self.get_instream_width())]
        code_gen_dict["$OBITS$"] = [str(self.get_outstream_width())]

        # Direct parameter assignments from KernelMetadata
        code_gen_dict["$INPUT_FPARG$"] = [str(self.get_nodeattr("input_FPARG"))]
        code_gen_dict["$BIAS$"] = [str(self.get_nodeattr("BIAS"))]
        code_gen_dict["$THRESHOLDS_PATH$"] = [str(self.get_nodeattr("THRESHOLDS_PATH"))]
        code_gen_dict["$DEPTH_TRIGGER_URAM$"] = [str(self.get_nodeattr("DEPTH_TRIGGER_URAM"))]
        code_gen_dict["$DEPTH_TRIGGER_BRAM$"] = [str(self.get_nodeattr("DEPTH_TRIGGER_BRAM"))]
        code_gen_dict["$DEEP_PIPELINE$"] = [str(self.get_nodeattr("DEEP_PIPELINE"))]

        # Interface-specific parameters
        # input BDIM parameters
        code_gen_dict["$INPUT_BDIM$"] = [str(self._get_interface_bdim("input", 0))]
        # input SDIM parameters
        code_gen_dict["$INPUT_SDIM$"] = [str(self._get_interface_sdim("input", 0))]

        # Interface datatype widths
        code_gen_dict["$INPUT_WIDTH$"] = [str(self._get_interface_width("input"))]
        code_gen_dict["$INPUT_SIGNED$"] = [str(1 if self._get_interface_signed("input") else 0)]
        code_gen_dict["$OUTPUT_WIDTH$"] = [str(self._get_interface_width("output"))]

        # Config interface parameters
        code_gen_dict["$T_WIDTH$"] = [str(self.get_nodeattr("width"))]

        # Standard interface width mappings
        code_gen_dict["$INPUT_STREAM_WIDTH$"] = [str(self._get_interface_width("input"))]
        code_gen_dict["$OUTPUT_STREAM_WIDTH$"] = [str(self._get_interface_width("output"))]

        # AXI-Lite configuration enable
        code_gen_dict["$USE_AXILITE$"] = [str(1)]

        # Extract PE and CHANNELS parameters if they exist
        # These often appear in shape expressions but need to be available as parameters
        if hasattr(self, "get_nodeattr"):
            try:
                pe_val = self.get_nodeattr("PE")
                code_gen_dict["$PE$"] = [str(pe_val)]
            except Exception:
                pass
            try:
                channels_val = self.get_nodeattr("CHANNELS")
                code_gen_dict["$CHANNELS$"] = [str(channels_val)]
            except Exception:
                pass

        return code_gen_dict

    def get_included_rtl_filenames(self) -> list[str]:
        """Get list of included RTL file names (basename only)."""
        return [
            os.path.basename(
                "/home/tafk/dev/brainsmith-1/examples/kernel_integrator/source/thresholding_axi.sv"
            ),
            os.path.basename("thresholding.sv"),
            os.path.basename(
                "/home/tafk/dev/brainsmith-1/deps/finn/finn-rtllib/axi/hdl/axilite.sv"
            ),
        ]

    def generate_hdl(self, model, fpgapart, clk):
        """Generate HDL from pre-generated wrapper template."""
        # Get code generation directory
        code_gen_dir = self.get_nodeattr("code_gen_dir_ipgen")
        os.makedirs(code_gen_dir, exist_ok=True)

        # Save top module name
        topname = self.get_verilog_top_module_name()
        self.set_nodeattr("gen_top_module", topname)

        # Get template variables
        code_gen_dict = self.prepare_codegen_rtl_values(model)

        # Find the pre-generated wrapper template
        module_dir = Path(__file__).parent
        wrapper_name = "thresholding_axi_wrapper.v"
        wrapper_path = module_dir / wrapper_name

        if wrapper_path.exists():
            # Read wrapper template
            with open(wrapper_path) as f:
                template_content = f.read()

            # Apply template substitution
            for placeholder, values in code_gen_dict.items():
                value = values[0] if isinstance(values, list) and values else str(values)
                template_content = template_content.replace(placeholder, value)

            # Write processed wrapper
            output_path = os.path.join(code_gen_dir, f"{topname}.v")
            with open(output_path, "w") as f:
                f.write(template_content)
        else:
            raise FileNotFoundError(
                f"Wrapper template not found at {wrapper_path}. "
                "Ensure the wrapper file is in the same directory as this RTL backend."
            )

        # Copy all included RTL files from kernel metadata
        included_files = [
            "/home/tafk/dev/brainsmith-1/examples/kernel_integrator/source/thresholding_axi.sv",
            "thresholding.sv",
            "/home/tafk/dev/brainsmith-1/deps/finn/finn-rtllib/axi/hdl/axilite.sv",
        ]
        self.copy_included_rtl_files(included_files, code_gen_dir)

        # Set paths for downstream tools
        self.set_nodeattr("ipgen_path", code_gen_dir)
        self.set_nodeattr("ip_path", code_gen_dir)

    def get_verilog_top_module_intf_names(self):
        """Return interface names for Verilog module based on actual RTL signal names."""
        intf_names = {}

        # Clock and reset signals from control interface
        intf_names["clk"] = ["ap_clk"]
        intf_names["rst"] = ["ap_rst_n"]

        # Stream interface names based on kernel metadata
        # Input stream interfaces (excluding weights)
        intf_names["s_axis"] = [
            ("in0_V", self.get_instream_width_padded(0)),
        ]

        # Output stream interfaces
        intf_names["m_axis"] = [
            ("out0_V", self.get_outstream_width_padded(0)),
        ]

        # AXI-Lite interface for configuration
        if self.get_nodeattr("USE_AXILITE") == 1:
            axilite_interfaces = []
            axilite_interfaces.append("weight")
            intf_names["axilite"] = axilite_interfaces

        return intf_names

    ############################################################################
    # ======================= MANUALLY IMPLEMENT FUNCTIONS BELOW ===============
    # Add any custom methods specific to your RTL backend here
    ############################################################################


# Kernel metadata reference
"""
thresholding_axi RTL Backend Specification:

Module: thresholding_axi
Source: /home/tafk/dev/brainsmith-1/examples/kernel_integrator/source/thresholding_axi.sv

Parameters:
- input_FPARG: RTL parameter (nodeattr: input_FPARG)
- BIAS: RTL parameter (nodeattr: BIAS)
- THRESHOLDS_PATH: RTL parameter (nodeattr: THRESHOLDS_PATH)
- DEPTH_TRIGGER_URAM: RTL parameter (nodeattr: DEPTH_TRIGGER_URAM)
- DEPTH_TRIGGER_BRAM: RTL parameter (nodeattr: DEPTH_TRIGGER_BRAM)
- DEEP_PIPELINE: RTL parameter (nodeattr: DEEP_PIPELINE)

Interfaces:
- input: INPUT interface- output: OUTPUT interface
- threshold: CONFIG interface (AXI-Lite)

Template Variables Generated:
- Module and stream width variables
- $INPUT_FPARG$: from nodeattr 'input_FPARG'
- $BIAS$: from nodeattr 'BIAS'
- $THRESHOLDS_PATH$: from nodeattr 'THRESHOLDS_PATH'
- $DEPTH_TRIGGER_URAM$: from nodeattr 'DEPTH_TRIGGER_URAM'
- $DEPTH_TRIGGER_BRAM$: from nodeattr 'DEPTH_TRIGGER_BRAM'
- $DEEP_PIPELINE$: from nodeattr 'DEEP_PIPELINE'
- $INPUT_WIDTH$: interface datatype width
- $INPUT_BDIM$: input BDIM parameter
- $INPUT_SDIM$: input SDIM parameter
- $OUTPUT_WIDTH$: interface datatype width
"""
