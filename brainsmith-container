#!/bin/bash
# Brainsmith Container Management Script
# Provides utilities for managing persistent Brainsmith containers

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

gecho () { echo -e "${GREEN}$1${NC}"; }
recho () { echo -e "${RED}$1${NC}"; }
yecho () { echo -e "${YELLOW}$1${NC}"; }
becho () { echo -e "${BLUE}$1${NC}"; }

# Auto-detect brainsmith directory (where this script lives)
SCRIPT_DIR=$(dirname "$(readlink -f "$0")")
export BSMITH_DIR=$(readlink -f "$SCRIPT_DIR")

# Generate unique container name based on brainsmith directory
BSMITH_DIR_HASH=$(echo "$BSMITH_DIR" | md5sum | cut -d' ' -f1 | head -c 8)
DOCKER_UNAME=$(id -un)
DOCKER_INST_NAME="brainsmith_dev_${DOCKER_UNAME}_${BSMITH_DIR_HASH}"
DOCKER_INST_NAME="${DOCKER_INST_NAME,,}"

# Set defaults (same as run-docker.sh)
: ${BSMITH_HW_COMPILER="finn"}

# Handle Docker tag with CI fallback
if [ -z "$BSMITH_DOCKER_TAG" ]; then
    # Try git describe first, fallback to commit hash for CI
    GIT_TAG=$(cd $BSMITH_DIR; git describe --always --tags --dirty 2>/dev/null)
    if [ -n "$GIT_TAG" ] && [ "$GIT_TAG" != "$(cd $BSMITH_DIR; git rev-parse --short HEAD 2>/dev/null)" ]; then
        BSMITH_DOCKER_TAG="microsoft/brainsmith:$GIT_TAG"
    else
        # Fallback for CI or when no tags
        COMMIT_HASH=$(cd $BSMITH_DIR; git rev-parse --short HEAD 2>/dev/null || echo "latest")
        BSMITH_DOCKER_TAG="microsoft/brainsmith:ci-$COMMIT_HASH"
    fi
fi
: ${LOCALHOST_URL="localhost"}
: ${NETRON_PORT=8080}
: ${NUM_DEFAULT_WORKERS=4}
: ${NVIDIA_VISIBLE_DEVICES=""}

: ${BSMITH_BUILD_DIR="/tmp/$DOCKER_INST_NAME"}
: ${BSMITH_SSH_KEY_DIR="$BSMITH_DIR/ssh_keys"}
: ${PLATFORM_REPO_PATHS="/opt/xilinx/platforms"}
: ${OHMYXILINX="${BSMITH_DIR}/deps/oh-my-xilinx"}
: ${VIVADO_HLS_LOCAL=$VIVADO_PATH}
: ${VIVADO_IP_CACHE=$BSMITH_BUILD_DIR/vivado_ip_cache}
: ${DOCKER_BUILDKIT="1"}
: ${BSMITH_DOCKER_PREBUILT="0"}
: ${BSMITH_DOCKER_NO_CACHE="0"}
: ${BSMITH_SKIP_DEP_REPOS="0"}
: ${BSMITH_DOCKER_RUN_AS_ROOT="0"}
: ${BSMITH_DOCKER_GPU="$(docker info | grep nvidia | wc -m)"}
: ${BSMITH_DOCKER_BUILD_FLAGS=""}
: ${BSMITH_DOCKER_FLAGS=""}

show_help() {
    cat << EOF
Brainsmith Container Management

Usage: $0 [COMMAND] [OPTIONS]

Commands:
    start [MODE]    Start a persistent Brainsmith container
                   MODE: interactive (default), daemon
    stop           Stop the running container
    restart        Restart the container
    status         Show container status
    exec CMD       Execute command in running container
    shell          Open an interactive shell in running container
    logs           Show container logs
    cleanup        Remove stopped container and cleanup
    build          Build the Docker image
    help           Show this help

Examples:
    $0 start              # Start interactive container
    $0 start daemon       # Start container in background
    $0 exec "python -c 'import brainsmith; print(brainsmith.__version__)'"
    $0 shell              # Get interactive shell
    $0 stop               # Stop container

Environment Variables:
    BSMITH_DOCKER_TAG       Docker image tag to use
    BSMITH_BUILD_DIR        Host build directory
    BSMITH_QUICK_EXEC       Set to 1 to skip environment setup for exec
EOF
}

get_container_status() {
    docker inspect "$DOCKER_INST_NAME" >/dev/null 2>&1
    if [ $? -eq 0 ]; then
        STATUS=$(docker inspect --format='{{.State.Status}}' "$DOCKER_INST_NAME")
        echo "$STATUS"
    else
        echo "not_found"
    fi
}

is_container_running() {
    STATUS=$(get_container_status)
    [ "$STATUS" = "running" ]
}

build_image() {
    gecho "Building Docker image $BSMITH_DOCKER_TAG"
    
    OLD_PWD=$(pwd)
    cd $BSMITH_DIR
    
    [ "$BSMITH_DOCKER_NO_CACHE" = "1" ] && BSMITH_DOCKER_BUILD_FLAGS+="--no-cache "
    
    docker build -f docker/Dockerfile \
        --build-arg BACKEND=$BSMITH_HW_COMPILER \
        --build-arg ENTRYPOINT=docker/entrypoint.sh \
        --tag=$BSMITH_DOCKER_TAG \
        $BSMITH_DOCKER_BUILD_FLAGS .
    
    cd $OLD_PWD
}

start_container() {
    MODE=${1:-interactive}
    
    STATUS=$(get_container_status)
    
    if [ "$STATUS" = "running" ]; then
        gecho "Container $DOCKER_INST_NAME is already running"
        return 0
    elif [ "$STATUS" = "exited" ]; then
        gecho "Starting existing container $DOCKER_INST_NAME"
        docker start "$DOCKER_INST_NAME"
        return $?
    fi
    
    # Build image if it doesn't exist or if not using prebuilt
    if [ "$BSMITH_DOCKER_PREBUILT" = "0" ]; then
        build_image
    fi
    
    gecho "Creating new container $DOCKER_INST_NAME"
    
    # Create necessary directories
    mkdir -p $BSMITH_BUILD_DIR
    
    # Build Docker command with all required options
    DOCKER_CMD="docker run"
    
    if [ "$MODE" = "daemon" ]; then
        DOCKER_CMD+=" -d"
    else
        DOCKER_CMD+=" -it"
    fi
    
    DOCKER_CMD+=" --name $DOCKER_INST_NAME"
    DOCKER_CMD+=" --init --hostname $DOCKER_INST_NAME"
    DOCKER_CMD+=" -e SHELL=/bin/bash"
    DOCKER_CMD+=" -w $BSMITH_DIR"
    
    # Essential volume mounts
    DOCKER_CMD+=" -v $BSMITH_DIR:$BSMITH_DIR"
    DOCKER_CMD+=" -v $BSMITH_BUILD_DIR:$BSMITH_BUILD_DIR"
    
    # Essential environment variables
    DOCKER_CMD+=" -e BSMITH_BUILD_DIR=$BSMITH_BUILD_DIR"
    DOCKER_CMD+=" -e BSMITH_DIR=$BSMITH_DIR"
    DOCKER_CMD+=" -e LOCALHOST_URL=$LOCALHOST_URL"
    DOCKER_CMD+=" -e NUM_DEFAULT_WORKERS=$NUM_DEFAULT_WORKERS"
    
    # User/permission setup (unless running as root)
    if [ "$BSMITH_DOCKER_RUN_AS_ROOT" = "0" ]; then
        DOCKER_CMD+=" -v /etc/group:/etc/group:ro"
        DOCKER_CMD+=" -v /etc/passwd:/etc/passwd:ro"
        DOCKER_CMD+=" -v /etc/shadow:/etc/shadow:ro"
        DOCKER_CMD+=" -v /etc/sudoers.d:/etc/sudoers.d:ro"
        DOCKER_CMD+=" --user $(id -u):$(id -g)"
    fi
    
    # Dependency and Xilinx setup (if not skipping deps)
    if [ "$BSMITH_SKIP_DEP_REPOS" = "0" ]; then
        DOCKER_CMD+=" -e VIVADO_IP_CACHE=$VIVADO_IP_CACHE"
        DOCKER_CMD+=" -e OHMYXILINX=$OHMYXILINX"
        
        # Xilinx workarounds
        DOCKER_CMD+=" -e LD_PRELOAD=/lib/x86_64-linux-gnu/libudev.so.1"
        DOCKER_CMD+=" -e XILINX_LOCAL_USER_DATA=no"
        
        # Xilinx tools (if available)
        if [ ! -z "$BSMITH_XILINX_PATH" ]; then
            VIVADO_PATH="$BSMITH_XILINX_PATH/Vivado/$BSMITH_XILINX_VERSION"
            VITIS_PATH="$BSMITH_XILINX_PATH/Vitis/$BSMITH_XILINX_VERSION"
            HLS_PATH="$BSMITH_XILINX_PATH/Vitis_HLS/$BSMITH_XILINX_VERSION"
            
            DOCKER_CMD+=" -v $BSMITH_XILINX_PATH:$BSMITH_XILINX_PATH"
            [ -d "$VIVADO_PATH" ] && DOCKER_CMD+=" -e XILINX_VIVADO=$VIVADO_PATH -e VIVADO_PATH=$VIVADO_PATH"
            [ -d "$HLS_PATH" ] && DOCKER_CMD+=" -e HLS_PATH=$HLS_PATH"
            [ -d "$VITIS_PATH" ] && DOCKER_CMD+=" -e VITIS_PATH=$VITIS_PATH"
            [ -d "$PLATFORM_REPO_PATHS" ] && DOCKER_CMD+=" -v $PLATFORM_REPO_PATHS:$PLATFORM_REPO_PATHS -e PLATFORM_REPO_PATHS=$PLATFORM_REPO_PATHS"
        fi
    fi
    
    # GPU support
    if [ "$BSMITH_DOCKER_GPU" != 0 ]; then
        gecho "nvidia-docker detected, enabling GPUs"
        if [ ! -z "$NVIDIA_VISIBLE_DEVICES" ]; then
            DOCKER_CMD+=" --runtime nvidia -e NVIDIA_VISIBLE_DEVICES=$NVIDIA_VISIBLE_DEVICES"
        else
            DOCKER_CMD+=" --gpus all"
        fi
    fi
    
    # Additional flags
    DOCKER_CMD+=" $BSMITH_DOCKER_FLAGS"
    
    # Image and command
    if [ "$MODE" = "daemon" ]; then
        # Use sleep infinity for proper signal handling and daemon mode
        DOCKER_CMD+=" $BSMITH_DOCKER_TAG sleep infinity"
        gecho "Starting daemon container..."
        $DOCKER_CMD
    else
        DOCKER_CMD+=" $BSMITH_DOCKER_TAG bash"
        gecho "Starting interactive container..."
        exec $DOCKER_CMD
    fi
}

stop_container() {
    if is_container_running; then
        gecho "Stopping container $DOCKER_INST_NAME"
        docker stop "$DOCKER_INST_NAME"
    else
        yecho "Container $DOCKER_INST_NAME is not running"
    fi
}

restart_container() {
    stop_container
    sleep 2
    start_container daemon
}

show_status() {
    STATUS=$(get_container_status)
    case "$STATUS" in
        "running")
            gecho "Container $DOCKER_INST_NAME is running"
            docker ps --filter "name=$DOCKER_INST_NAME" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            ;;
        "exited")
            yecho "Container $DOCKER_INST_NAME exists but is stopped"
            ;;
        "not_found")
            recho "Container $DOCKER_INST_NAME does not exist"
            ;;
        *)
            yecho "Container $DOCKER_INST_NAME status: $STATUS"
            ;;
    esac
}

exec_in_container() {
    if ! is_container_running; then
        recho "Container $DOCKER_INST_NAME is not running. Start it first with: $0 start daemon"
        return 1
    fi
    
    if [ $# -eq 0 ]; then
        recho "No command specified for exec"
        return 1
    fi
    
    # Build command with proper quoting
    CMD=""
    for arg in "$@"; do
        if [ -z "$CMD" ]; then
            CMD="$arg"
        else
            CMD="$CMD $arg"
        fi
    done
    
    # Use the fast exec entrypoint for optimized performance
    docker exec "$DOCKER_INST_NAME" /usr/local/bin/entrypoint_exec.sh bash -c "$CMD"
}

open_shell() {
    if ! is_container_running; then
        recho "Container $DOCKER_INST_NAME is not running. Start it first with: $0 start daemon"
        return 1
    fi
    
    gecho "Opening shell in container $DOCKER_INST_NAME"
    docker exec -it "$DOCKER_INST_NAME" bash
}

show_logs() {
    docker logs "$DOCKER_INST_NAME" "$@"
}

cleanup_container() {
    STATUS=$(get_container_status)
    if [ "$STATUS" != "not_found" ]; then
        gecho "Removing container $DOCKER_INST_NAME"
        docker rm -f "$DOCKER_INST_NAME"
    else
        yecho "Container $DOCKER_INST_NAME does not exist"
    fi
}

# Main command handling
case "${1:-help}" in
    "start")
        start_container "$2"
        ;;
    "stop")
        stop_container
        ;;
    "restart")
        restart_container
        ;;
    "status")
        show_status
        ;;
    "exec")
        shift
        exec_in_container "$@"
        ;;
    "shell")
        open_shell
        ;;
    "logs")
        shift
        show_logs "$@"
        ;;
    "cleanup")
        cleanup_container
        ;;
    "build")
        build_image
        ;;
    "help"|"-h"|"--help")
        show_help
        ;;
    *)
        recho "Unknown command: $1"
        show_help
        exit 1
        ;;
esac
